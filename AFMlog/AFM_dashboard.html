<!DOCTYPE html>
<html lang="de">
<!-- Removed the data-theme="dark" attribute to prevent flash -->
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <title>AnyFileMonitor Dashboard</title>
  
  <!-- PWA Support -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#3f51b5">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="AFM Dashboard">
  <link rel="apple-touch-icon" href="images/icon-152x152.png">
  
  <!-- Material Design Lite -->
  <link rel="stylesheet" href="libs/fonts/material-icons.css">
  <link rel="stylesheet" href="libs/css/material.indigo-pink.min.css">
  <script defer src="libs/js/material.min.js"></script>
  <!-- PapaParse für CSV-Parsing -->
  <script src="libs/js/papaparse.min.js"></script>  <!-- Chart.js für Diagramme -->
  <script src="libs/js/chart.js"></script>
  <script src="libs/js/chartjs-chart-matrix.min.js"></script>
  <script src="libs/js/chartjs-plugin-datalabels.js"></script>
  <!-- Moment.js für Datumsfunktionen -->
  <script src="libs/js/moment.min.js"></script>
  <script src="libs/js/moment-de.js"></script>
  <!-- noUiSlider für den Zeitraum-Slider -->
  <link rel="stylesheet" href="libs/css/nouislider.min.css">
  <script src="libs/js/nouislider.min.js"></script>
  <style>
    :root {
      /* Light Theme Variablen */
      --bg-color: #f5f5f5;
      --card-bg-color: #ffffff;
      --text-color: #000000;
      --secondary-text-color: #757575;
      --header-bg-color: #3f51b5;
      --header-text-color: #ffffff;
      --card-title-bg-color: #3f51b5;
      --card-title-text-color: #ffffff;
      --card-shadow: 0 2px 5px 0 rgba(0,0,0,0.16), 0 2px 10px 0 rgba(0,0,0,0.12);
      --accent-color: #3f51b5;
      --hover-color: rgba(0, 0, 0, 0.05);
      --border-color: #ddd;
      --chart-grid-color: rgba(0, 0, 0, 0.1);
      --success-color: #4caf50;
      --warning-color: #ff9800;
      --error-color: #f44336;
      --error-card-bg: #ffebee;
      --error-card-border: #f44336;
      --warning-card-bg: #fff8e1;
      --warning-card-border: #ffc107;
      --success-card-bg: #e8f5e9;
      --success-card-border: #4caf50;
      --tooltip-bg: #555;
      --tooltip-text: #fff;
    }

    [data-theme="dark"] {
      /* Dark Theme Variablen */
      --bg-color: #121212;
      --card-bg-color: #1e1e1e;
      --text-color: #e0e0e0;
      --secondary-text-color: #aaaaaa;
      --header-bg-color: #272727;
      --header-text-color: #e0e0e0;
      --card-title-bg-color: #272727;
      --card-title-text-color: #e0e0e0;
      --card-shadow: 0 2px 5px 0 rgba(0,0,0,0.5), 0 2px 10px 0 rgba(0,0,0,0.5);
      --accent-color: #5c6bc0;
      --hover-color: rgba(255, 255, 255, 0.05);
      --border-color: #444;
      --chart-grid-color: rgba(255, 255, 255, 0.1);
      --success-color: #81c784;
      --warning-color: #ffb74d;
      --error-color: #e57373;
      --error-card-bg: rgba(244, 67, 54, 0.15);
      --error-card-border: #e57373;
      --warning-card-bg: rgba(255, 193, 7, 0.15);
      --warning-card-border: #ffb74d;
      --success-card-bg: rgba(76, 175, 80, 0.15);
      --success-card-border: #81c784;
      --tooltip-bg: #333;
      --tooltip-text: #e0e0e0;
    }
    
    [data-theme="dark"] #healthScore {
      color: var(--text-color); /* Verwende die Textfarbe aus dem Dark Mode Farbschema */
    }

    [data-theme="dark"] #topErrorsList div {
      color: #ffffff; /* Weiß-Ton nur im Dark Mode */
    }
    
    body { 
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }
    .page-content {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .mdl-card {
      width: 100%;
      margin-bottom: 24px;
      overflow: visible;
      background-color: var(--card-bg-color);
      box-shadow: var(--card-shadow);
      transition: margin-bottom 0.3s ease-out;
    }
    .mdl-card__title {
      color: var(--card-title-text-color);
      height: 64px;
      background-color: var(--card-title-bg-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }
    .mdl-card__title-text {
      font-size: 20px;
      color: var(--card-title-text-color);
      flex: 1;
    }
    .toggle-card-btn {
      color: var(--card-title-text-color);
      background-color: transparent;
    }    .mdl-card__supporting-text {
      position: relative;
      overflow: hidden;
      transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                  opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                  padding 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      padding: 16px;
      margin: 0 auto;
      border-radius: 0 0 4px 4px;
      max-height: 2000px; /* Large enough for all content */
    }
    
    .mdl-card__supporting-text.collapsed {
      max-height: 0 !important;
      padding: 0 !important;
      margin: 0 !important;
      opacity: 0;
      border: none !important;
      overflow: hidden !important;
      display: none !important;
      pointer-events: none;
    }
    
    .mdl-card.collapsed-card {
      margin-bottom: 8px;
    }
    
    /* Add these new rules to ensure chart containers collapse */
    .mdl-card__supporting-text.collapsed .chart-container {
      display: none !important;
    }
    /* More efficient way to disable canvas rendering when collapsed */
    .mdl-card__supporting-text.collapsed canvas {
      /* Hide but keep in document for quicker reactivation */
      display: none !important;
    }
    .mdl-data-table {
      width: 100%;
      background-color: var(--card-bg-color);
      color: var(--text-color);
      border-color: var(--border-color);
    }
    .mdl-data-table th {
      color: var(--text-color);
      border-bottom-color: var(--border-color);
    }
    .mdl-data-table td {
      color: var(--text-color);
      border-bottom-color: var(--border-color);
    }
    .summary-card {
      padding: 16px;
      margin-bottom: 24px;
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      background-color: var(--card-bg-color);
    }
    .summary-item {
      text-align: center;
      padding: 16px;
      flex: 1;
      min-width: 150px;
    }
    .summary-value {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 8px;
      color: var(--accent-color);
    }
    .summary-label {
      font-size: 14px;
      color: var(--secondary-text-color);
    }
    .chart-container {
      height: 300px;
      margin-bottom: 24px;
      background-color: var(--card-bg-color);
    }
    .small-chart-container {
      height: 250px;
      margin-bottom: 16px;
      background-color: var(--card-bg-color);
    }
    .refresh-button {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 100;
    }
    .auto-refresh-toggle {
      position: fixed;
      bottom: 100px;
      right: 24px;
      z-index: 100;
      background-color: var(--accent-color);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 8px 16px;
      height: auto;
      width: auto;
      border-radius: 4px;
    }
    
    .auto-refresh-toggle[data-state="off"] {
      background-color: var(--secondary-text-color);
    }
    
    .auto-refresh-label {
      font-size: 12px;
      color: white;
      margin-bottom: 4px;
    }
    
    .auto-refresh-status {
      font-weight: bold;
      font-size: 14px;
      color: white;
    }
    
    .mdl-spinner {
      margin: 0 auto;
      display: block;
    }
    .loading {
      text-align: center;
      padding: 24px;
      color: var(--secondary-text-color);
    }
    .error-card {
      background-color: var(--error-card-bg);
      border-left: 4px solid var(--error-card-border);
    }
    .warning-card {
      background-color: var(--warning-card-bg);
      border-left: 4px solid var(--warning-card-border);
    }
    .success-card {
      background-color: var(--success-card-bg);
      border-left: 4px solid var(--success-card-border);
    }
    #lastUpdate {
      text-align: right;
      color: var(--secondary-text-color);
      font-size: 12px;
      margin-bottom: 16px;
    }
    .mdl-layout__header {
      background-color: var(--header-bg-color);
    }
    .mdl-layout__header-row {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      padding: 0 16px;
    }
    
    .mdl-layout-title {
      text-align: center;
      font-size: 20px;
      font-weight: bold;
      white-space: nowrap;
      grid-column: 2;
      color: var(--header-text-color);
    }
    
    .header-left {
      display: flex;
      align-items: center;
      justify-content: flex-start;
    }
    
    .header-right {
      display: flex;
      justify-content: flex-end;
      grid-column: 3;
    }
    
    .mdl-navigation {
      display: flex;
      justify-content: flex-end;
      width: 100%;
    }
    .mdl-navigation__link {
      color: var(--header-text-color) !important;
    }
    .mdl-grid {
      padding: 0;
    }
    .mdl-cell {
      margin: 8px;
    }
    .kpi-card {
      padding: 16px;
      text-align: center;
      border-radius: 8px;
      border-top: 4px solid var(--accent-color);
      background-color: var(--card-bg-color);
      box-shadow: var(--card-shadow);
    }
    .kpi-value {
      font-size: 28px;
      font-weight: bold;
      margin: 8px 0;
      color: var(--accent-color);
    }
    .kpi-label {
      font-size: 14px;
      color: var(--secondary-text-color);
    }
    .status-indicator {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      margin-right: 8px;
    }
    .status-good {
      background-color: var(--success-color);
    }
    .status-warning {
      background-color: var(--warning-color);
    }
    .status-error {
      background-color: var(--error-color);
    }
    .filter-container {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      margin-bottom: 16px;
      flex-wrap: wrap;
      background-color: var(--card-bg-color);
      position: relative;
    }
    .filter-item {
      margin: 8px;
    }
    .filter-label {
      font-size: 14px;
      margin-bottom: 8px;
      color: white;
      text-align: center;
      font-weight: 500;
      width: 100%;
      background-color: var(--accent-color);
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    .filter-group {
      display: flex;
      flex-direction: column;
      margin: 8px 16px;
      align-items: center;
    }
    
    .date-time-input-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .tab-container {
      display: none;
    }
    .tab-container.active {
      display: block;
    }
    .pattern-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      color: var(--card-title-text-color);
      background-color: var(--accent-color);
      margin-right: 4px;
      margin-bottom: 4px;
    }
    .pattern-container {
      margin-top: 8px;
    }
    #searchInput {
      padding: 8px;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 16px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--card-bg-color);
      color: var(--text-color);
    }
    .info-icon {
      font-size: 16px;
      color: var(--secondary-text-color);
      cursor: help;
    }
    .tooltip {
      position: relative;
      display: inline-block;
    }
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: var(--tooltip-bg);
      color: var(--tooltip-text);
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    .two-columns {
      column-count: 2;
      column-gap: 20px;
    }
    
    /* Date/Time Picker Custom Styles */
    .date-time-flex-container {
      display: flex;
      align-items: center;
      gap: 16px;
      position: relative;
    }
    
    .input-with-controls {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .input-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 40px;
    }
    
    .control-button {
      width: 32px;
      height: 32px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: var(--card-bg-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
    }
    
    [data-theme="dark"] .control-button {
      background-color: #333;
      border-color: #555;
      color: #e0e0e0;
    }
    
    [data-theme="dark"] .control-button:hover {
      background-color: #444;
    }
    
    [data-theme="dark"] .control-button .material-icons {
      color: #e0e0e0;
    }
    
    .control-button:hover {
      background-color: var(--hover-color);
    }
    
    .value-display {
      padding: 4px;
      min-width: 40px;
      text-align: center;
      font-weight: bold;
      cursor: default;
    }
    
    .value-display.editable {
      cursor: text;
      border: 1px dashed var(--accent-color);
      background-color: rgba(54, 162, 235, 0.1);
    }
    
    .edit-mode-btn {
      position: absolute;
      right: -10px;
      top: -10px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background-color: var(--accent-color);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      border: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      z-index: 10;
    }
    
    .separator {
      font-weight: bold;
      margin: 0 4px;
    }
    
    .hidden-input {
      position: absolute;
      opacity: 0;
      height: 0;
      width: 0;
    }
    
    .gauge-container {
      width: 200px;
      height: 100px;
      margin: 0 auto;
      position: relative;
    }
    .gauge-container canvas {
      width: 100%;
      height: 100%;
    }
    .gauge-label {
      position: absolute;
      bottom: 0;
      width: 100%;
      text-align: center;
      font-size: 14px;
      color: var(--secondary-text-color);
    }
    
    /* Styling für den Theme-Toggle-Button */
    .theme-toggle {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
      margin-right: 16px;
    }
    
    .theme-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .theme-toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }
    
    .theme-toggle-slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .theme-toggle-slider {
      background-color: var(--accent-color);
    }
    
    input:checked + .theme-toggle-slider:before {
      transform: translateX(30px);
    }
    
    .theme-toggle-icon {
      position: absolute;
      top: 6px;
      transition: .4s;
      font-size: 16px;
      color: white;
    }
    
    .theme-toggle-icon.sun {
      left: 8px;
      opacity: 0;
    }
    
    .theme-toggle-icon.moon {
      right: 8px;
      opacity: 1;
    }
    
    input:checked + .theme-toggle-slider .theme-toggle-icon.sun {
      opacity: 0;
    }
    
    input:checked + .theme-toggle-slider .theme-toggle-icon.moon {
      opacity: 1;
    }
    
    input:not(:checked) + .theme-toggle-slider .theme-toggle-icon.sun {
      opacity: 1;
    }
    
    input:not(:checked) + .theme-toggle-slider .theme-toggle-icon.moon {
      opacity: 0;
    }
    
    .mdl-layout__drawer {
      background-color: var(--card-bg-color);
      color: var(--text-color);
      border-color: var(--border-color);
    }
    
    .mdl-layout__drawer .mdl-navigation__link {
      color: var(--text-color) !important;
    }
    
    .mdl-layout__drawer .mdl-navigation__link:hover {
      background-color: var(--hover-color);
    }
    
    .mdl-button {
      color: var(--text-color);
    }
    
    .mdl-button--raised {
      background-color: var(--card-bg-color);
      color: var(--text-color);
    }

    .mdl-button--raised.mdl-button--colored {
      background-color: var(--accent-color);
      color: var(--card-title-text-color);
    }

    .mdl-layout-title {
      color: var(--header-text-color);
    }
    
    .mdl-layout__drawer .mdl-layout-title {
      color: var(--text-color);
      background-color: var(--card-bg-color);
    }

    .mdl-button--fab.mdl-button--colored {
      background: var(--accent-color);
      color: var(--card-title-text-color);
    }
    
    /* Dark-Mode Anpassungen für Input-Elemente */
    input[type="date"], input[type="time"] {
      background-color: var(--card-bg-color);
      color: var(--text-color);
      border: 1px solid var(--border-color);
    }

    /* Quick Filter Styling */
    .quick-filter-container {
      display: flex;
      align-items: center;
      margin-bottom: 16px;
      padding: 8px 16px;
      background-color: var(--card-bg-color);
      border-radius: 4px;
      box-shadow: var(--card-shadow);
      position: absolute;
      top: 8px;
      right: 16px;
      z-index: 10;
    }    .mdl-menu__item {
      color: var(--text-color);
    }
    
    .mdl-menu__item:hover {
      background-color: rgba(63, 81, 181, 0.1);
      color: var(--accent-color);
      transition: background-color 0.2s, color 0.2s;
    }

    .mdl-menu {
      background-color: var(--card-bg-color);
    }

    .filter-container {
      position: relative;
    }

    .date-time-input-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .input-with-controls {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .input-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 40px;
    }

    .control-button {
      width: 32px;
      height: 32px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: var(--card-bg-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
    }

    .control-button:hover {
      background-color: var(--hover-color);
    }

    .value-display {
      padding: 4px;
      min-width: 40px;
      text-align: center;
      font-weight: bold;
      cursor: default;
    }

    .value-display.editable {
      cursor: text;
      border: 1px dashed var(--accent-color);
      background-color: rgba(54, 162, 235, 0.1);
    }

    .edit-mode-btn {
      position: absolute;
      right: -10px;
      top: -10px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background-color: var(--accent-color);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      border: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      z-index: 10;
    }

    .separator {
      font-weight: bold;
      margin: 0 4px;
    }

    .hidden-input {
      position: absolute;
      opacity: 0;
      height: 0;
      width: 0;
    }

    .date-time-flex-container {
      display: flex;
      align-items: center;
      gap: 16px;
      position: relative;
    }

    .timeframe-indicator {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 4px 12px;
      margin: 0 16px;
      background-color: var(--accent-color);
      color: white;
      border-radius: 8px;
      min-width: 150px;
      text-align: center;
    }
    
    .timeframe-controls {
      display: flex;
      align-items: center;
      width: 100%;
    }
    
    .timeframe-content {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      align-items: center;
      padding: 0 8px;
    }
    
    .timeframe-button {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      padding: 0 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.8;
      transition: opacity 0.2s;
    }
    
    .timeframe-button:hover {
      opacity: 1;
    }
    
    .timeframe-indicator-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }    .timeframe-indicator-value {
      font-weight: bold;
      font-size: 14px;
    }    /* Collapsible Filter Styles */
    .filter-header {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 20px;
      background-color: var(--card-title-bg-color);
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
    }
    
    .filter-header.collapsed {
      border-radius: 4px;
      margin-bottom: 16px;
    }
    
    .filter-title {
      font-size: 16px;
      font-weight: 500;
    }
    
    #toggleFilterBtn {
      color: white;
    }
      .filter-container {
      max-height: 1000px; /* Large enough to contain all content */
      overflow: hidden;
      transition: max-height 0.3s ease-out;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto 16px;
      border-radius: 0 0 4px 4px;
    }
    
    .filter-container.collapsed {
      max-height: 0;
      padding: 0 !important;
      margin-top: 0;
      border-top: none;
    }
    
    /* Date Range Slider Styles */
    .date-range-slider-container {
      width: 100%;
      max-width: 900px;
      margin: 20px auto 16px;
      padding: 16px 25px;
      position: relative;
    }
      .slider-controls {
      display: flex;
      align-items: center;
      margin-top: 20px;
    }
    
    .slider-container {
      padding: 15px 10px 0;
      flex-grow: 1;
    }
    
    .range-shift-button {
      color: var(--accent-color);
      background-color: transparent;
      margin: 0 4px;
      transition: background-color 0.2s;
    }
    
    .range-shift-button:hover {
      background-color: rgba(63, 81, 181, 0.1);
    }
    
    .range-shift-button i {
      font-size: 28px;
    }
    
    .noUi-connect {
      background-color: var(--accent-color);
    }
    
    .noUi-horizontal {
      height: 8px;
    }
    
    .noUi-horizontal .noUi-handle {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: var(--accent-color);
      box-shadow: 0 0 0 2px white;
      cursor: pointer;
      top: -7px;
      right: -10px;
    }
    
    .noUi-handle:before,
    .noUi-handle:after {
      display: none; /* Remove default lines in handles */
    }
    
    .slider-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
    }
    
    .slider-tooltip {
      display: block;
      position: absolute;
      background-color: var(--accent-color);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      bottom: 30px;
      transform: translateX(-50%);
      text-align: center;
      white-space: nowrap;
    }
    
    .slider-markers {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      position: relative;
      height: 16px;
    }
    
    .slider-marker {
      position: absolute;
      width: 2px;
      height: 10px;
      background-color: var(--secondary-text-color);
      bottom: 0;
      transform: translateX(-50%);
    }
    
    .slider-marker-label {
      position: absolute;
      bottom: -15px;
      transform: translateX(-50%);
      font-size: 10px;
      color: var(--secondary-text-color);
      white-space: nowrap;
    }
    
    .date-range-slider-title {
      color: white;
      font-size: 14px;
      font-weight: 500;
      padding: 4px 0;
      text-align: center;
      background-color: var(--accent-color);
      border-radius: 4px;
      margin-bottom: 10px;
    }
    
    .slider-timestamp-display {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }
    
    .slider-timestamp {
      padding: 6px 10px;
      background-color: var(--accent-color);
      color: white;
      border-radius: 4px;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header">
    <header class="mdl-layout__header">
      <div class="mdl-layout__header-row">        <div class="header-left" style="display: flex; align-items: center; margin-right: auto;">
          <!-- Theme-Toggle-Button mit Abstand zum Burger-Menü -->
          <label class="theme-toggle" style="margin-left: 48px;">
            <input type="checkbox" id="themeToggle" checked>
            <span class="theme-toggle-slider">
              <i class="material-icons theme-toggle-icon sun">wb_sunny</i>
              <i class="material-icons theme-toggle-icon moon">nights_stay</i>
            </span>
          </label>
        </div>
        <span class="mdl-layout-title">
          <img src="images/icon-72x72.png" alt="AFM Logo" style="height: 32px; width: 32px; margin-right: 10px; vertical-align: middle;">
          AnyFileMonitor Dashboard
        </span>
        <div class="header-right">
          <nav class="mdl-navigation">
            <a class="mdl-navigation__link" href="#overview" onclick="showTab('overview')">Übersicht</a>
            <a class="mdl-navigation__link" href="#status" onclick="showTab('status')">Status</a>
            <a class="mdl-navigation__link" href="#analysis" onclick="showTab('analysis')">Analyse</a>
            <a class="mdl-navigation__link" href="#errors" onclick="showTab('errors')">Fehler</a>
            <a class="mdl-navigation__link" href="#patterns" onclick="showTab('patterns')">Muster</a>
            <a class="mdl-navigation__link" href="#input" onclick="showTab('input')">Eingangsdaten</a>
          </nav>
        </div>
      </div>
    </header>
    <div class="mdl-layout__drawer">
      <span class="mdl-layout-title"> </span>
      <nav class="mdl-navigation">
        <a class="mdl-navigation__link" href="#overview" onclick="showTab('overview')">Übersicht</a>
        <a class="mdl-navigation__link" href="#status" onclick="showTab('status')">Status</a>
        <a class="mdl-navigation__link" href="#analysis" onclick="showTab('analysis')">Analyse</a>
        <a class="mdl-navigation__link" href="#errors" onclick="showTab('errors')">Fehler</a>
        <a class="mdl-navigation__link" href="#patterns" onclick="showTab('patterns')">Muster</a>
        <a class="mdl-navigation__link" href="#input" onclick="showTab('input')">Eingangsdaten</a>
      </nav>
    </div>
    <main class="mdl-layout__content">
      <div class="page-content">
        <div id="lastUpdate"></div>        <!-- Filter für Zeitraum -->
        <div class="filter-header mdl-shadow--2dp">
          <div class="filter-title">Zeitraumfilter</div>
          <button id="toggleFilterBtn" class="mdl-button mdl-js-button mdl-button--icon" title="Filter ein-/ausklappen">
            <i class="material-icons" id="toggleFilterIcon">expand_less</i>
          </button>
        </div>
        <div class="filter-container mdl-shadow--2dp" id="filterContent" style="padding: 16px; background-color: var(--card-bg-color); display: flex; justify-content: center; align-items: flex-start;">
          <!-- Date Range Slider -->
          <div class="date-range-slider-container mdl-shadow--2dp">
            <div class="date-range-slider-title">Zeitraumauswahl</div>
            <div class="slider-controls">
              <button class="mdl-button mdl-js-button mdl-button--icon range-shift-button" id="shiftRangeLeft" title="Zeitraum zurück verschieben">
                <i class="material-icons">keyboard_arrow_left</i>
              </button>
              <div class="slider-container">
                <div id="dateRangeSlider"></div>
                <div class="slider-markers" id="sliderMarkers"></div>
              </div>
              <button class="mdl-button mdl-js-button mdl-button--icon range-shift-button" id="shiftRangeRight" title="Zeitraum vorwärts verschieben">
                <i class="material-icons">keyboard_arrow_right</i>
              </button>
            </div>
            <div class="slider-timestamp-display">
              <div class="slider-timestamp" id="sliderStartTimestamp">Start: --</div>
              <div class="slider-timestamp" id="sliderEndTimestamp">Ende: --</div>
            </div>
          </div>
          
          <!-- Quick Filter Menu -->
          <div class="quick-filter-container">
            <button id="quick-filter-button" class="mdl-button mdl-js-button mdl-button--icon" title="Quick Filter">
              <i class="material-icons">filter_list</i>
            </button>
              <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="quick-filter-button">
              <li class="mdl-menu__item" onclick="applyQuickFilter(5, 'minute')">Letzte 5 Minuten</li>
              <li class="mdl-menu__item" onclick="applyQuickFilter(15, 'minute')">Letzte 15 Minuten</li>
              <li class="mdl-menu__item" onclick="applyQuickFilter(30, 'minute')">Letzte 30 Minuten</li>
              <li class="mdl-menu__item" onclick="applyQuickFilter(60, 'minute')">Letzte 60 Minuten</li>
              <li class="mdl-menu__item" onclick="applyQuickFilter(4, 'hour')">Letzte 4 Stunden</li>
              <li class="mdl-menu__item" onclick="applyQuickFilter(8, 'hour')">Letzte 8 Stunden</li>
              <li class="mdl-menu__item" onclick="applyQuickFilter(1, 'day')">Letzter Tag</li>
              <li class="mdl-menu__item" onclick="applyQuickFilter(7, 'day')">Letzte Woche</li>
              <li class="mdl-menu__item" onclick="applyQuickFilter(30, 'day')">Letzter Monat</li>
            </ul>
          </div>
          
          <div class="filter-group" style="display: flex; flex-direction: column; margin: 8px 16px; justify-content: flex-start;">
            <label class="filter-label" style="color: white; margin-top: 0;">Startdatum und -zeit</label>
            <div class="date-time-input-group">
              <div class="date-time-flex-container">
                <!-- Date Input with Controls -->
                <div class="input-with-controls">
                  <!-- Date Sections (Day, Month, Year with individual controls) -->
                  <div class="input-section">
                    <button class="control-button up" onclick="adjustDate('startDate', 1, 'day')">
                      <i class="material-icons">keyboard_arrow_up</i>
                    </button>
                    <div class="value-display">Tag</div>
                    <button class="control-button down" onclick="adjustDate('startDate', -1, 'day')">
                      <i class="material-icons">keyboard_arrow_down</i>
                    </button>
                  </div>
                  
                  <span class="separator">/</span>
                  
                  <div class="input-section">
                    <button class="control-button up" onclick="adjustDate('startDate', 1, 'month')">
                      <i class="material-icons">keyboard_arrow_up</i>
                    </button>
                    <div class="value-display">Monat</div>
                    <button class="control-button down" onclick="adjustDate('startDate', -1, 'month')">
                      <i class="material-icons">keyboard_arrow_down</i>
                    </button>
                  </div>
                  
                  <span class="separator">/</span>
                  
                  <div class="input-section">
                    <button class="control-button up" onclick="adjustDate('startDate', 1, 'year')">
                      <i class="material-icons">keyboard_arrow_up</i>
                    </button>
                    <div class="value-display">Jahr</div>
                    <button class="control-button down" onclick="adjustDate('startDate', -1, 'year')">
                      <i class="material-icons">keyboard_arrow_down</i>
                    </button>
                  </div>
                  
                  <!-- Actual input field (can be hidden or shown as needed) -->
                  <input type="date" id="startDate" class="hidden-input" onchange="updateDateDisplay('startDate')">
                </div>
                
                <!-- Time Input with Controls -->
                <div class="input-with-controls">
                  <!-- Time Sections -->
                  <div class="input-section">
                    <button class="control-button up" onclick="adjustTime('startTime', 1, 'hour')">
                      <i class="material-icons">keyboard_arrow_up</i>
                    </button>
                    <div class="value-display">Std</div>
                    <button class="control-button down" onclick="adjustTime('startTime', -1, 'hour')">
                      <i class="material-icons">keyboard_arrow_down</i>
                    </button>
                  </div>
                  
                  <div class="separator">:</div>
                  
                  <div class="input-section">
                    <button class="control-button up" onclick="adjustTime('startTime', 5, 'minute')">
                      <i class="material-icons">keyboard_arrow_up</i>
                    </button>
                    <div class="value-display">Min</div>
                    <button class="control-button down" onclick="adjustTime('startTime', -5, 'minute')">
                      <i class="material-icons">keyboard_arrow_down</i>
                    </button>
                  </div>
                  
                  <!-- Actual input field -->
                  <input type="time" id="startTime" class="hidden-input" onchange="updateTimeDisplay('startTime')">
                </div>
              </div>
            </div>
          </div>
          
          <!-- Timeframe Indicator -->
          <div class="timeframe-indicator">      <div class="timeframe-controls">
              <button class="timeframe-button" onclick="movePreviousPeriod()">
                <i class="material-icons">navigate_before</i>
              </button>
              <div class="timeframe-content">
                <span class="timeframe-indicator-label">Zeitraum</span>
                <span class="timeframe-indicator-value" id="timeframeDisplay">01.01.23 00:00 - 02.01.23 23:59</span>
              </div>
              <button class="timeframe-button" onclick="moveNextPeriod()">
                <i class="material-icons">navigate_next</i>
              </button>
            </div>
          </div>
          
          <div class="filter-group" style="display: flex; flex-direction: column; margin: 8px 16px; justify-content: flex-start;">
            <label class="filter-label" style="color: white; margin-top: 0;">Enddatum und -zeit</label>
            <div class="date-time-input-group">
              <div class="date-time-flex-container">
                <!-- Date Input with Controls -->
                <div class="input-with-controls">
                  <!-- Date Sections (Day, Month, Year with individual controls) -->
                  <div class="input-section">
                    <button class="control-button up" onclick="adjustDate('endDate', 1, 'day')">
                      <i class="material-icons">keyboard_arrow_up</i>
                    </button>
                    <div class="value-display">Tag</div>
                    <button class="control-button down" onclick="adjustDate('endDate', -1, 'day')">
                      <i class="material-icons">keyboard_arrow_down</i>
                    </button>
                  </div>
                  
                  <span class="separator">/</span>
                  
                  <div class="input-section">
                    <button class="control-button up" onclick="adjustDate('endDate', 1, 'month')">
                      <i class="material-icons">keyboard_arrow_up</i>
                    </button>
                    <div class="value-display">Monat</div>
                    <button class="control-button down" onclick="adjustDate('endDate', -1, 'month')">
                      <i class="material-icons">keyboard_arrow_down</i>
                    </button>
                  </div>
                  
                  <span class="separator">/</span>
                  
                  <div class="input-section">
                    <button class="control-button up" onclick="adjustDate('endDate', 1, 'year')">
                      <i class="material-icons">keyboard_arrow_up</i>
                    </button>
                    <div class="value-display">Jahr</div>
                    <button class="control-button down" onclick="adjustDate('endDate', -1, 'year')">
                      <i class="material-icons">keyboard_arrow_down</i>
                    </button>
                  </div>
                  
                  <input type="date" id="endDate" class="hidden-input" onchange="updateDateDisplay('endDate')">
                </div>
                
                <!-- Time Input with Controls -->
                <div class="input-with-controls">
                  <!-- Time Sections -->
                  <div class="input-section">
                    <button class="control-button up" onclick="adjustTime('endTime', 1, 'hour')">
                      <i class="material-icons">keyboard_arrow_up</i>
                    </button>
                    <div class="value-display">Std</div>
                    <button class="control-button down" onclick="adjustTime('endTime', -1, 'hour')">
                      <i class="material-icons">keyboard_arrow_down</i>
                    </button>
                  </div>
                  
                  <div class="separator">:</div>
                  
                  <div class="input-section">
                    <button class="control-button up" onclick="adjustTime('endTime', 5, 'minute')">
                      <i class="material-icons">keyboard_arrow_up</i>
                    </button>
                    <div class="value-display">Min</div>
                    <button class="control-button down" onclick="adjustTime('endTime', -5, 'minute')">
                      <i class="material-icons">keyboard_arrow_down</i>
                    </button>
                  </div>
                  
                  <input type="time" id="endTime" class="hidden-input" onchange="updateTimeDisplay('endTime')">
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Übersicht Tab -->
        <div id="overview" class="tab-container active">
          <!-- Zusammenfassung -->
          <div class="mdl-grid summary-card mdl-shadow--2dp">
            <div class="summary-item">
              <div class="summary-value" id="totalFiles">-</div>
              <div class="summary-label">
                Dateien gesamt
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Gesamtanzahl aller verarbeiteten Dateien (Input + Archiv + Fehler)</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="errorCount">-</div>
              <div class="summary-label">
                Fehler
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Anzahl der aufgetretenen Fehler im ausgewählten Zeitraum</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="patternCount">-</div>
              <div class="summary-label">
                Muster erkannt
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Anzahl der Fehler, die einem bekannten Muster zugeordnet werden konnten</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="errorRate">-</div>
              <div class="summary-label">
                Fehlerrate
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Prozentualer Anteil der Fehler an der Gesamtzahl der Dateien</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="lastRunTime">-</div>
              <div class="summary-label">
                Letzte Ausführung
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Zeitpunkt der letzten Ausführung des AnyFileMonitors</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="systemStatus">
                <span class="status-indicator status-good" id="statusIndicator"></span>
                <span id="statusText">Gut</span>
              </div>
              <div class="summary-label">
                Systemstatus
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Aktueller Zustand des Systems basierend auf der Fehlerrate (Gut: <5%, Warnung: 5-10%, Kritisch: >10%)</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="inputFiles">-</div>
              <div class="summary-label">
                Input-Dateien
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Anzahl der Dateien, die aktuell im Input-Verzeichnis liegen</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="archiveFiles">-</div>
              <div class="summary-label">
                Archiv-Dateien
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Anzahl der Dateien, die erfolgreich verarbeitet und archiviert wurden</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="errorFiles">-</div>
              <div class="summary-label">
                Fehler-Dateien
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Anzahl der Dateien, die nicht verarbeitet werden konnten und im Fehler-Verzeichnis liegen</span>
                </span>
              </div>
            </div>
          </div>

          <!-- System-Gesundheit -->
          <div class="mdl-grid">
            <div class="mdl-cell mdl-cell--4-col">
              <div id="healthCard" class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">System-Gesundheit</h2>
                  <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('healthCard')" title="Ein-/ausklappen">
                    <i class="material-icons">expand_less</i>
                  </button>
                </div>
                <div class="mdl-card__supporting-text">
                  <div class="gauge-container">
                    <canvas id="healthGauge"></canvas>
                    <div class="gauge-label">Systemstatus</div>
                  </div>
                  <div style="margin-top: 16px; text-align: center;">
                    <span id="healthScore">100%</span> Gesundheit
                  </div>
                </div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--4-col">
              <div id="errorDistributionCard" class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">Fehler-Verteilung</h2>
                  <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('errorDistributionCard')" title="Ein-/ausklappen">
                    <i class="material-icons">expand_less</i>
                  </button>
                </div>
                <div class="mdl-card__supporting-text">
                  <div class="small-chart-container">
                    <canvas id="errorTypePieChart"></canvas>
                  </div>
                </div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--4-col">
              <div id="topErrorsCard" class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">Top Fehler</h2>
                  <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('topErrorsCard')" title="Ein-/ausklappen">
                    <i class="material-icons">expand_less</i>
                  </button>
                </div>
                <div class="mdl-card__supporting-text">
                  <div id="topErrorsList">Lädt...</div>
                </div>
              </div>
            </div>
          </div>

          <!-- KPI-Übersicht -->
          <div class="mdl-grid">
            <div class="mdl-cell mdl-cell--3-col">
              <div class="kpi-card">
                <div class="kpi-label">
                  Durchsatz (Dateien/Stunde)
                  <span class="tooltip">
                    <i class="material-icons info-icon">info_outline</i>
                    <span class="tooltiptext">Durchschnittliche Anzahl der verarbeiteten Dateien pro Stunde</span>
                  </span>
                </div>
                <div class="kpi-value" id="throughput">-</div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--3-col">
              <div class="kpi-card">
                <div class="kpi-label">
                  Archiv : Fehler
                  <span class="tooltip">
                    <i class="material-icons info-icon">info_outline</i>
                    <span class="tooltiptext">Verhältnis zwischen archivierten und fehlerhaften Dateien</span>
                  </span>
                </div>
                <div class="kpi-value" id="archiveToErrorRatio">-</div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--3-col">
              <div class="kpi-card">
                <div class="kpi-label">
                  Fehlerintensität
                  <span class="tooltip">
                    <i class="material-icons info-icon">info_outline</i>
                    <span class="tooltiptext">Durchschnittliche Anzahl der Fehler pro Stunde im ausgewählten Zeitraum</span>
                  </span>
                </div>
                <div class="kpi-value" id="errorIntensityKPI">-</div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--3-col">
              <div class="kpi-card">
                <div class="kpi-label">
                  Fehlertrend
                  <span class="tooltip">
                    <i class="material-icons info-icon">info_outline</i>
                    <span class="tooltiptext">Prozentuale Veränderung der Fehleranzahl im Vergleich zum vorherigen Zeitraum</span>
                  </span>
                </div>
                <div class="kpi-value" id="errorTrendKPI">-</div>
              </div>
            </div>
          </div>          <!-- Fehler nach Tageszeit -->
          <div id="errorsByHourCard" class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehler nach Tageszeit</h2>
              <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('errorsByHourCard')" title="Ein-/ausklappen">
                <i class="material-icons">expand_less</i>
              </button>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="errorsByHourChart"></canvas>
              </div>
            </div>
          </div>          <!-- Fehler nach Wochentag (replaced with Fehlertypen nach Wochentagen) -->
          <div id="errorsByWeekdayCard" class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehlertypen nach Wochentagen</h2>
              <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('errorsByWeekdayCard')" title="Ein-/ausklappen">
                <i class="material-icons">expand_less</i>
              </button>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="errorsByWeekdayStackedChart2"></canvas>
              </div>
            </div>
          </div>
        </div>

        <!-- Status Tab -->
        <div id="status" class="tab-container">          <!-- Status-Diagramme - Aufgeteilt in drei separate Diagramme -->
          <div id="inputChartCard" class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Input-Verlauf</h2>
              <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('inputChartCard')" title="Ein-/ausklappen">
                <i class="material-icons">expand_less</i>
              </button>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="inputChart"></canvas>
              </div>
            </div>
          </div>          <div id="archiveChartCard" class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Archiv-Verlauf</h2>
              <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('archiveChartCard')" title="Ein-/ausklappen">
                <i class="material-icons">expand_less</i>
              </button>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="archiveChart"></canvas>
              </div>
            </div>
          </div>          <div id="errorChartCard" class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Error-Verlauf</h2>
              <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('errorChartCard')" title="Ein-/ausklappen">
                <i class="material-icons">expand_less</i>
              </button>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="errorChart"></canvas>
              </div>
            </div>
          </div>          <!-- Status-Log -->
          <div id="statusLogCard" class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Status-Log (AFM_status_log.csv)</h2>
              <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('statusLogCard')" title="Ein-/ausklappen">
                <i class="material-icons">expand_less</i>
              </button>
            </div>
            <div class="mdl-card__supporting-text">
              <div id="statusTable" class="loading">
                <div class="mdl-spinner mdl-js-spinner is-active"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Analyse Tab -->
        <div id="analysis" class="tab-container">          <!-- Fehler-Trend nach Typ -->
          <div id="errorTrendCard" class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehler-Trend nach Typ</h2>
              <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('errorTrendCard')" title="Ein-/ausklappen">
                <i class="material-icons">expand_less</i>
              </button>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="errorTrendChart"></canvas>
              </div>
            </div>
          </div>
            <!-- Fehler-Verteilung nach Wochentagen -->
          <div id="errorHeatmapCard" class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehlertypen nach Wochentagen</h2>
              <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('errorHeatmapCard')" title="Ein-/ausklappen">
                <i class="material-icons">expand_less</i>
              </button>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="errorHeatmapChart"></canvas>
              </div>
            </div>
          </div>
          
          <!-- Verarbeitungseffizienz -->
          <div class="mdl-grid">            <div class="mdl-cell mdl-cell--6-col">
              <div id="errorRateCard" class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">Fehlerrate-Verlauf</h2>
                  <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('errorRateCard')" title="Ein-/ausklappen">
                    <i class="material-icons">expand_less</i>
                  </button>
                </div>
                <div class="mdl-card__supporting-text">
                  <div class="small-chart-container">
                    <canvas id="errorRateChart"></canvas>
                  </div>
                </div>
              </div>
            </div>            <div class="mdl-cell mdl-cell--6-col">
              <div id="throughputCard" class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">Durchsatz-Verlauf</h2>
                  <button class="mdl-button mdl-js-button mdl-button--icon toggle-card-btn" onclick="toggleCard('throughputCard')" title="Ein-/ausklappen">
                    <i class="material-icons">expand_less</i>
                  </button>
                </div>
                <div class="mdl-card__supporting-text">
                  <div class="small-chart-container">
                    <canvas id="throughputChart"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Fehler Tab -->
        <div id="errors" class="tab-container">
          <input type="text" id="searchInput" placeholder="Nach Dateinamen oder Fehlermeldung suchen..." onkeyup="searchErrors()">
          
          <!-- Fehler-Log -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehler-Log (AFM_error_log.csv)</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div id="errorTable" class="loading">
                <div class="mdl-spinner mdl-js-spinner is-active"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Muster Tab -->
        <div id="patterns" class="tab-container">
          <!-- Muster-Treffer -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Erkannte Muster (AFM_pattern_matches.csv)</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div id="patternTable" class="loading">
                <div class="mdl-spinner mdl-js-spinner is-active"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Eingangsdaten Tab -->
        <div id="input" class="tab-container">
          <!-- Eingangsdetails -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Eingangsdetails (AFM_input_details.csv)</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div id="inputTable" class="loading">
                <div class="mdl-spinner mdl-js-spinner is-active"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- Refresh Button -->
  <button class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect mdl-button--colored refresh-button" onclick="loadAllData()">
    <i class="material-icons">refresh</i>
  </button>

  <!-- Auto-refresh toggle as a button -->
  <button id="autoRefreshToggle" class="mdl-button mdl-js-button mdl-js-ripple-effect auto-refresh-toggle" onclick="toggleAutoRefresh()">
    <div class="auto-refresh-content">
      <div class="auto-refresh-label">Auto-Refresh: 5min</div>
      <div class="auto-refresh-status">ON</div>
    </div>
  </button>

  <script>
    // Globale Variablen
    let allStatusData = [];
    let allErrorData = [];
    let allPatternData = [];
    let allInputData = [];
    let filteredStatusData = [];
    let filteredErrorData = [];
    let filteredPatternData = [];
    let filteredInputData = [];
    let startDateFilter = null;
    let endDateFilter = null;
    let startTimeFilter = null;
    let endTimeFilter = null;
    
    // Bekannte Fehlermuster aus config.ini - wird dynamisch geladen
    let knownErrorPatterns = [];

    // Auto-refresh Intervall
    let autoRefreshInterval = null;

    // Konfiguration aus config.ini laden
    function loadConfig() {
      fetch('./config.ini')
        .then(response => {
          if (!response.ok) {
            throw new Error('Fehler beim Laden der Konfiguration');
          }
          return response.text();
        })
        .then(configText => {
          // config.ini parsen
          const configLines = configText.split('\n');
          let errorPatterns = '';
          
          // Nach der errorPatterns-Zeile suchen
          for (const line of configLines) {
            if (line.trim().startsWith('errorPatterns=')) {
              errorPatterns = line.trim().substring('errorPatterns='.length);
              break;
            }
          }
          
          // Muster aufteilen und in Array speichern
          knownErrorPatterns = errorPatterns.split(',').map(pattern => pattern.trim());
          console.log('Geladene Fehlermuster:', knownErrorPatterns);
          
          // Nach dem Laden der Konfiguration die Daten aktualisieren
          loadAllData();
        })
        .catch(error => {
          console.error('Fehler beim Laden der config.ini:', error);
          // Fallback zu Default-Werten
          knownErrorPatterns = [
            "Timeout", 
            "Zeitüberschreitung", 
            "Verbindung vom peer", 
            "multiple Rows in singleton select", 
            "deadlock", 
            "lock conflict on no wait transaction",
            "nicht definiert"
          ];
          loadAllData();
        });
    }

    // Datumsfilter initialisieren
    function initDateFilter() {
      // Heutiges Datum
      const today = new Date();
      const todayFormatted = today.toISOString().split('T')[0]; // YYYY-MM-DD Format
      
      // Morgiges Datum
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      const tomorrowFormatted = tomorrow.toISOString().split('T')[0]; // YYYY-MM-DD Format
      
      // Eingabefelder mit den Werten füllen
      document.getElementById('startDate').value = todayFormatted;
      document.getElementById('endDate').value = tomorrowFormatted;
      
      // Uhrzeitwerte setzen (00:00 für beide)
      document.getElementById('startTime').value = '00:00';
      document.getElementById('endTime').value = '00:00';
      
      // Filter-Variablen setzen
      startDateFilter = new Date(today);
      startDateFilter.setHours(0, 0, 0, 0); // Beginn des heutigen Tages (00:00:00)
      
      endDateFilter = new Date(tomorrow);
      endDateFilter.setHours(0, 0, 0, 0); // Beginn des morgigen Tages (00:00:00)
      
      // Initialize date and time displays
      initDateTimeDisplays();
      
      // Initialize the timeframe display explicitly
      updateTimeframeDisplay();
      
      // Filter automatisch anwenden, ohne Klick auf den Button zu erfordern
      applyFilters();
      processAllData();
    }

    // Tab-Steuerung
    function showTab(tabId) {
      // Alle Tabs verstecken
      document.querySelectorAll('.tab-container').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Ausgewählten Tab anzeigen
      document.getElementById(tabId).classList.add('active');
      
      // Aktivität in der Navigation markieren
      document.querySelectorAll('.mdl-navigation__link').forEach(link => {
        if (link.getAttribute('href') === '#' + tabId) {
          link.classList.add('is-active');
        } else {
          link.classList.remove('is-active');
        }
      });
    }    // Datum-Filter anwenden
    function applyDateFilter() {
      const startInput = document.getElementById('startDate');
      const endInput = document.getElementById('endDate');
      const startTimeInput = document.getElementById('startTime');
      const endTimeInput = document.getElementById('endTime');
      
      // Vollständige Zeitstempel erstellen, die Datum und Uhrzeit korrekt kombinieren
      if (startInput.value) {
        // Verwende direkt die ISO-Datumszeit-Kombination für korrekte Parsung
        const startTimeStr = startTimeInput.value || "00:00";
        const startDateTime = `${startInput.value}T${startTimeStr}`;
        startDateFilter = new Date(startDateTime);
        console.log("Start filter with time:", startDateTime, startDateFilter);
      } else {
        startDateFilter = null;
      }
      
      if (endInput.value) {
        // Verwende direkt die ISO-Datumszeit-Kombination für korrekte Parsung
        const endTimeStr = endTimeInput.value || "00:00";
        const endDateTime = `${endInput.value}T${endTimeStr}`;
        const endDate = new Date(endDateTime);
        
        // Setze die Sekunden und Millisekunden auf Ende der Minute
        endDate.setSeconds(59, 999);
        endDateFilter = endDate;
        console.log("End filter with time:", endDateTime, endDateFilter);
      } else {
        endDateFilter = null;
      }
      
      // Update the noUISlider to match the new date range
      if (window.dateSlider && startDateFilter && endDateFilter) {
        window.dateSlider.set([
          startDateFilter.getTime(), 
          endDateFilter.getTime()
        ]);
        
        // Also update the displayed timestamps under the slider
        const formatSliderDate = (timestamp) => {
          const date = new Date(timestamp);
          return moment(date).format('DD.MM.YYYY HH:mm');
        };
        
        document.getElementById('sliderStartTimestamp').textContent = 
          'Start: ' + formatSliderDate(startDateFilter);
        document.getElementById('sliderEndTimestamp').textContent = 
          'Ende: ' + formatSliderDate(endDateFilter);
      }
      
      applyFilters();
      processAllData();
      
      // Update the timeframe indicator display
      updateTimeframeDisplay();
    }

    // Datum-Filter zurücksetzen
    function resetDateFilter() {
      document.getElementById('startDate').value = '';
      document.getElementById('endDate').value = '';
      document.getElementById('startTime').value = '';
      document.getElementById('endTime').value = '';
      startDateFilter = null;
      endDateFilter = null;
      
      applyFilters();
      processAllData();
    }

    // Filter auf Daten anwenden
    function applyFilters() {
      filteredStatusData = filterDataByDate(allStatusData);
      filteredErrorData = filterDataByDate(allErrorData);
      filteredPatternData = filterDataByDate(allPatternData);
      filteredInputData = filterDataByDate(allInputData);
    }

    // Datum-Filter anwenden
    function filterDataByDate(data) {
      if (!startDateFilter && !endDateFilter) {
        return [...data]; // Kopie des Arrays zurückgeben, wenn kein Filter aktiv
      }
      
      return data.filter(row => {
        if (!row.Zeitpunkt) return true;
        
        // Zeitstempel aus dem Datensatz parsen
        const [datePart, timePart] = row.Zeitpunkt.split(' ');
        const [year, month, day] = datePart.split('-').map(num => parseInt(num));
        const [hours, minutes, seconds] = timePart.split(':').map(num => parseInt(num));
        
        // JavaScript Monate sind 0-basiert (0 = Januar)
        const rowDate = new Date(year, month - 1, day, hours, minutes, seconds);
        
        if (startDateFilter && rowDate < startDateFilter) return false;
        if (endDateFilter && rowDate > endDateFilter) return false;
        
        return true;
      });
    }

    // Fehlertabelle durchsuchen
    function searchErrors() {
      const searchTerm = document.getElementById('searchInput').value.toLowerCase();
      const errorTable = document.getElementById('errorTable');
      
      if (!errorTable) return;
      
      const rows = errorTable.querySelectorAll('tbody tr');
      
      rows.forEach(row => {
        const rowText = row.textContent.toLowerCase();
        if (rowText.includes(searchTerm)) {
          row.style.display = '';
        } else {
          row.style.display = 'none';
        }
      });
    }

    // Hauptfunktion zum Laden aller Daten anpassen
    function loadAllData() {
      document.getElementById('lastUpdate').textContent = 'Letzte Aktualisierung: ' + new Date().toLocaleString('de-DE');
      
      // Promise-basierte Verarbeitung der Daten
      Promise.all([
        new Promise(resolve => loadCSV('./AFM_status_log.csv', results => {
          allStatusData = results.data || [];
          resolve();
        })),
        new Promise(resolve => loadCSV('./AFM_error_log.csv', results => {
          allErrorData = results.data || [];
          resolve();
        })),
        new Promise(resolve => loadCSV('./AFM_pattern_matches.csv', results => {
          allPatternData = results.data || [];
          resolve();
        })),
        new Promise(resolve => loadCSV('./AFM_input_details.csv', results => {
          allInputData = results.data || [];
          resolve();
        }))      ]).then(() => {
        // Nach dem Laden aller Daten Filter anwenden
        applyFilters();
        processAllData();
        
        // Initialize date range slider after data is loaded
        initDateRangeSlider();
      });
    }

    function processAllData() {
      processStatusData({ data: filteredStatusData });
      processErrorData({ data: filteredErrorData });
      processPatternData({ data: filteredPatternData });
      processInputData({ data: filteredInputData });
      
      // Zusätzliche Analysen
      calculateKPIs();
      createErrorTrendChart();
      createErrorRateChart();
      createThroughputChart();
      createErrorsByHourChart();
      createErrorTypePieChart();
      updateTopErrorsList();
      updateSystemHealthGauge();
      createErrorsByWeekdayChart();
      createErrorsByWeekdayStackedChart(); 
      
      // Create duplicate chart for overview tab
      createErrorsByWeekdayStackedChart2();
    }

    function loadCSV(file, callback) {
      Papa.parse(file, {
        download: true,
        header: true,
        delimiter: ";", // Semikolon als Trennzeichen festlegen
        skipEmptyLines: true,
        complete: callback
      });
    }

    // Status-Daten verarbeiten with improved charting
    function processStatusData(results) {
      if (!results.data || results.data.length === 0) {
        document.getElementById('statusTable').innerHTML = '<p>Keine Status-Daten verfügbar.</p>';
        return;
      }

      // Tabelle erstellen
      renderTable(results.data, 'statusTable');

      // Letzte Ausführung anzeigen
      const lastRun = results.data[results.data.length - 1];
      if (lastRun && lastRun.Zeitpunkt) {
        document.getElementById('lastRunTime').textContent = lastRun.Zeitpunkt.split(' ')[1] || '-';
      }

      // Berechne die Summen für den Filterzeitraum
      if (results.data.length > 0) {
        // Den letzten Eintrag im gefilterten Zeitraum verwenden
        const lastEntry = results.data[results.data.length - 1];
        
        // Werte aus dem letzten Eintrag extrahieren und sicherstellen, dass sie gültige Zahlen sind
        const inputVal = parseInt(lastEntry['Input'] || 0);
        const errorVal = parseInt(lastEntry['Error'] || 0);
        const archiveVal = parseInt(lastEntry['Archiv'] || 0);
        
        // Werte anzeigen
        document.getElementById('inputFiles').textContent = inputVal;
        document.getElementById('errorFiles').textContent = errorVal;
        document.getElementById('archiveFiles').textContent = archiveVal;
        
        // Gesamtzahl der Dateien berechnen
        const totalFiles = inputVal + errorVal + archiveVal;
        document.getElementById('totalFiles').textContent = totalFiles;
        
        // Fehlerrate berechnen
        calculateErrorRate();
      }      // Group data by 15-minute intervals for better visualization
      const inputBy15Min = {};
      const errorByHour = {};
      const archiveByHour = {};
      
      // Process data points in chronological order
      results.data.sort((a, b) => new Date(a.Zeitpunkt) - new Date(b.Zeitpunkt));
      
      results.data.forEach(entry => {
        if (!entry.Zeitpunkt) return;
        
        // Extract date and round to 15-minute interval
        const timestamp = new Date(entry.Zeitpunkt);
        const minutes = timestamp.getMinutes();
        // Round to nearest 15-minute interval (0, 15, 30, 45)
        const roundedMinutes = Math.floor(minutes / 15) * 15;
        
        const min15Key = new Date(
          timestamp.getFullYear(),
          timestamp.getMonth(),
          timestamp.getDate(),
          timestamp.getHours(),
          roundedMinutes
        ).toISOString();
        
        // Store input values by 15-minute buckets
        if (!inputBy15Min[min15Key]) {
          inputBy15Min[min15Key] = { sum: 0, count: 0 };
        }
        
        // Sum input values for this 15-minute interval
        inputBy15Min[min15Key].sum += parseInt(entry['Input'] || 0);
        inputBy15Min[min15Key].count++;
        
        // Keep hourly buckets for error and archive charts
        const hourKey = new Date(
          timestamp.getFullYear(),
          timestamp.getMonth(),
          timestamp.getDate(),
          timestamp.getHours()
        ).toISOString();
        
        // Store values for hourly buckets for error and archive
        if (!errorByHour[hourKey]) {
          errorByHour[hourKey] = { sum: 0, count: 0 };
          archiveByHour[hourKey] = { sum: 0, count: 0 };
        }
        
        // Sum values for error and archive hourly data
        errorByHour[hourKey].sum += parseInt(entry['Error'] || 0);
        errorByHour[hourKey].count++;
        archiveByHour[hourKey].sum += parseInt(entry['Archiv'] || 0);
        archiveByHour[hourKey].count++;
      });
        // Create labels and data arrays for the charts
      const inputLabels = [];
      const inputData = [];
      const errorLabels = [];
      const errorData = [];
      const archiveLabels = [];
      const archiveData = [];
      
      // Format and prepare the input data with 15-minute intervals
      Object.entries(inputBy15Min)
        .sort(([a], [b]) => a.localeCompare(b)) // Sort by timestamp
        .forEach(([min15Key, values]) => {
          const date = new Date(min15Key);
          const formattedTime = `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')} ${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;
          inputLabels.push(formattedTime);
          
          // Calculate average values for each 15-minute interval
          inputData.push(Math.round(values.sum / values.count));
        });
      
      // Keep hourly intervals for error and archive data
      Object.entries(errorByHour)
        .sort(([a], [b]) => a.localeCompare(b)) // Sort by timestamp
        .forEach(([hourKey, values]) => {
          const date = new Date(hourKey);
          const formattedHour = `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')} ${date.getHours()}:00`;
          errorLabels.push(formattedHour);
          archiveLabels.push(formattedHour);
          
          // Calculate average values for each hour
          errorData.push(Math.round(errorByHour[hourKey].sum / errorByHour[hourKey].count));
          archiveData.push(Math.round(archiveByHour[hourKey].sum / archiveByHour[hourKey].count));
        });      // Create Input Chart with improved styling for 15-minute intervals
      const ctxInput = document.getElementById('inputChart').getContext('2d');
      if (window.inputChart instanceof Chart) {
        window.inputChart.destroy();
      }
      
      window.inputChart = new Chart(ctxInput, {
        type: 'line',
        data: {
          labels: inputLabels,
          datasets: [{
            label: 'Input',
            data: inputData,
            borderColor: 'rgba(54, 162, 235, 1)',
            backgroundColor: 'rgba(54, 162, 235, 0.2)',
            borderWidth: 2,
            tension: 0.3,
            fill: true,
            pointRadius: inputLabels.length > 30 ? 0 : 2, // Hide points if we have too many data points
            pointHoverRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Dateien'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Zeitraum (15-Minuten Intervalle)'
              },
              ticks: {
                maxRotation: 45,
                minRotation: 45,
                autoSkip: true,
                maxTicksLimit: 20 // Limit the number of ticks to prevent overcrowding
              }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                title: function(context) {
                  return context[0].label;
                },
                label: function(context) {
                  return `Input: ${context.raw} Dateien`;
                }
              }
            },
            title: {
              display: true,
              text: 'Input-Verlauf (15-Minuten Intervalle)',
              font: {
                size: 16
              }
            }
          }
        }
      });      // Create Error Chart with improved styling
      const ctxError = document.getElementById('errorChart').getContext('2d');
      if (window.errorChart instanceof Chart) {
        window.errorChart.destroy();
      }
      
      window.errorChart = new Chart(ctxError, {
        type: 'line',
        data: {
          labels: errorLabels,
          datasets: [{
            label: 'Fehler',
            data: errorData,
            borderColor: 'rgba(255, 99, 132, 1)',
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            borderWidth: 2,
            tension: 0.3,
            fill: true,
            pointRadius: 3,
            pointHoverRadius: 5
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Fehler'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Zeitraum (Stunde)'
              },
              ticks: {
                maxRotation: 45,
                minRotation: 45
              }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                title: function(context) {
                  return context[0].label;
                },
                label: function(context) {
                  return `Fehler: ${context.raw} Dateien`;
                }
              }
            }
          }
        }
      });      // Create Archive Chart with improved styling
      const ctxArchive = document.getElementById('archiveChart').getContext('2d');
      if (window.archiveChart instanceof Chart) {
        window.archiveChart.destroy();
      }
      
      window.archiveChart = new Chart(ctxArchive, {
        type: 'line',
        data: {
          labels: archiveLabels,
          datasets: [{
            label: 'Archiv',
            data: archiveData,
            borderColor: 'rgba(75, 192, 192, 1)',
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
            borderWidth: 2,
            tension: 0.3,
            fill: true,
            pointRadius: 3,
            pointHoverRadius: 5
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Dateien'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Zeitraum (Stunde)'
              },
              ticks: {
                maxRotation: 45,
                minRotation: 45
              }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                title: function(context) {
                  return context[0].label;
                },
                label: function(context) {
                  return `Archiv: ${context.raw} Dateien`;
                }
              }
            }
          }
        }
      });
    }

    // Systemstatus aktualisieren
    function updateSystemStatus(errorRate) {
      const rateValue = parseFloat(errorRate);
      const indicator = document.getElementById('statusIndicator');
      const statusText = document.getElementById('statusText');
      
      if (rateValue < 5) {
        indicator.className = 'status-indicator status-good';
        statusText.textContent = 'Gut';
      } else if (rateValue < 10) {
        indicator.className = 'status-indicator status-warning';
        statusText.textContent = 'Warnung';
      } else {
        indicator.className = 'status-indicator status-error';
        statusText.textContent = 'Kritisch';
      }
    }

    // Fehler-Daten verarbeiten
    function processErrorData(results) {
      if (!results.data || results.data.length === 0) {
        document.getElementById('errorTable').innerHTML = '<p>Keine Fehler-Daten verfügbar.</p>';
        return;
      }

      document.getElementById('errorCount').textContent = results.data.length;
      renderTable(results.data, 'errorTable', true);
      
      // Fehlerrate wird nun zentral in calculateErrorRate() berechnet
      calculateErrorRate();
    }

    // Zentrale Funktion für die Berechnung der Fehlerrate
    function calculateErrorRate() {
      // Prüfen ob genügend Daten vorhanden sind
      if (filteredStatusData.length < 1) return;
        
      // Berechne die tatsächlich verarbeiteten Dateien während des Zeitraums
      let processedFiles = 0;
      let errorFiles = 0;
      
      if (filteredStatusData.length > 1) {
        // Differenz zwischen Anfang und Ende des Zeitraums
        const firstEntry = filteredStatusData[0];
        const lastEntry = filteredStatusData[filteredStatusData.length - 1];
        
        // Berechne die Veränderung im Archiv und Fehlerverzeichnis
        const archiveChange = parseInt(lastEntry['Archiv'] || 0) - parseInt(firstEntry['Archiv'] || 0);
        const errorChange = parseInt(lastEntry['Error'] || 0) - parseInt(firstEntry['Error'] || 0);
        
        // Die Anzahl der Fehlerdateien ist die positive Änderung im Fehlerverzeichnis
        errorFiles = Math.max(0, errorChange);
        
        // Die Summe der positiven Änderungen stellt die verarbeiteten Dateien dar
        processedFiles = Math.max(0, archiveChange) + errorFiles;
      } else {
        // Fallback für einzelnen Datenpunkt
        const singleEntry = filteredStatusData[0];
        processedFiles = parseInt(singleEntry['Error'] || 0) + parseInt(singleEntry['Archiv'] || 0);
        errorFiles = parseInt(singleEntry['Error'] || 0);
      }
      
      // Für Perioden, in denen nur Fehlerdateien verarbeitet wurden
      const errorCount = filteredErrorData.length;
      
      // Wenn keine Änderung oder negative Änderung (z.B. durch Dateilöschungen), verwenden wir die Fehleranzahl
      if (processedFiles === 0) {
        processedFiles = errorCount > 0 ? errorCount : 1; // Vermeidet Division durch Null
        errorFiles = errorCount;
      }
      
      // Wenn alle verarbeiteten Dateien Fehler sind und die Anzahl der Fehler mit errorFiles übereinstimmt,
      // dann haben wir eine 100% Fehlerrate
      if (processedFiles > 0 && processedFiles === errorFiles) {
        document.getElementById('errorRate').textContent = '100.0%';
        updateSystemStatus('100.0%');
        return '100.0%';
      }
      
      // Fehlerrate berechnen als Prozentsatz
      const errorRate = ((errorCount / processedFiles) * 100).toFixed(1) + '%';
      document.getElementById('errorRate').textContent = errorRate;
      
      // Systemstatus aktualisieren
      updateSystemStatus(errorRate);
      
      return errorRate;
    }

    // Muster-Daten verarbeiten
    function processPatternData(results) {
      if (!results.data || results.data.length === 0) {
        document.getElementById('patternTable').innerHTML = '<p>Keine Muster-Daten verfügbar.</p>';
        return;
      }

      document.getElementById('patternCount').textContent = results.data.length;
      renderTable(results.data, 'patternTable', true);
    }

    // Eingangs-Daten verarbeiten
    function processInputData(results) {
      if (!results.data || results.data.length === 0) {
        document.getElementById('inputTable').innerHTML = '<p>Keine Eingangs-Daten verfügbar.</p>';
        return;
      }

      renderTable(results.data, 'inputTable');
      document.getElementById('inputFiles').textContent = results.data.length;
      
      // Aktualisiere den Input-Files-Count in der Übersicht mit dem letzten Wert
      if (results.data.length > 0) {
        const latestInputData = results.data[results.data.length - 1];
        document.getElementById('inputFiles').textContent = latestInputData['Anzahl'];
      }
    }

    // Durchsatz berechnen als Differenz zwischen den letzten beiden Messungen
    function calculateThroughput(statusData) {
      if (statusData.length < 2) {
        return 0;
      }
      
      // Letzter und vorletzter Eintrag
      const lastEntry = statusData[statusData.length - 1];
      const prevEntry = statusData[statusData.length - 2];
      
      // Summe der verarbeiteten Dateien (Archiv + Error) für jede Messung
      const lastProcessed = parseInt(lastEntry['Archiv'] || 0) + parseInt(lastEntry['Error'] || 0);
      const prevProcessed = parseInt(prevEntry['Archiv'] || 0) + parseInt(prevEntry['Error'] || 0);
      
      // Differenz = Anzahl der neu verarbeiteten Dateien
      const processedDifference = lastProcessed - prevProcessed;
      
      // Zeitdifferenz in Stunden berechnen
      const lastTime = new Date(lastEntry.Zeitpunkt);
      const prevTime = new Date(prevEntry.Zeitpunkt);
      const hoursDiff = (lastTime - prevTime) / (1000 * 60 * 60); // Millisekunden in Stunden umrechnen
      
      // Durchsatz pro Stunde (hochgerechnet, falls das Intervall kürzer als eine Stunde ist)
      const throughputPerHour = hoursDiff > 0 ? Math.round(processedDifference / hoursDiff) : 0;
      
      return throughputPerHour;
    }

    // KPIs berechnen
    function calculateKPIs() {
      if (filteredStatusData.length < 2) return;

      // Fehlerintensität (Fehler pro Stunde)
      function calculateErrorIntensity() {
        if (filteredErrorData.length === 0) return "0";

        const startTime = startDateFilter ? startDateFilter.getTime() : new Date(filteredErrorData[0].Zeitpunkt).getTime();
        const endTime = endDateFilter ? endDateFilter.getTime() : new Date(filteredErrorData[filteredErrorData.length - 1].Zeitpunkt).getTime();

        const hours = Math.max(0.01, (endTime - startTime) / (1000 * 60 * 60));
        return (filteredErrorData.length / hours).toFixed(1);
      }

      // Fehlertrend (prozentuale Veränderung zum vorherigen Zeitraum)
      function calculateErrorTrend() {
        if (filteredErrorData.length === 0 || !startDateFilter || !endDateFilter) return "0%";

        const currentPeriodLength = endDateFilter.getTime() - startDateFilter.getTime();
        const prevPeriodStart = new Date(startDateFilter.getTime() - currentPeriodLength);
        const prevPeriodEnd = new Date(startDateFilter.getTime());

        const currentErrors = filteredErrorData.length;
        const prevErrors = allErrorData.filter(entry => {
          if (!entry.Zeitpunkt) return false;
          const timestamp = new Date(entry.Zeitpunkt).getTime();
          return timestamp >= prevPeriodStart.getTime() && timestamp <= prevPeriodEnd.getTime();
        }).length;

        if (prevErrors === 0 && currentErrors === 0) return "0%";
        if (prevErrors === 0) return currentErrors > 0 ? "+∞%" : "0%";

        const change = ((currentErrors - prevErrors) / prevErrors) * 100;
        const sign = change > 0 ? "+" : "";
        return `${sign}${change.toFixed(1)}%`;
      }

      // Fehlerintensität berechnen und anzeigen
      const errorIntensity = calculateErrorIntensity();
      document.getElementById('errorIntensityKPI').textContent = errorIntensity;

      // Fehlertrend berechnen und anzeigen
      const errorTrend = calculateErrorTrend();
      document.getElementById('errorTrendKPI').textContent = errorTrend;

      // Durchsatz-Berechnung
      const throughputPerHour = calculateThroughput(filteredStatusData);
      document.getElementById('throughput').textContent = throughputPerHour;
      
      // Archiv zu Fehler Verhältnis - Modifiziert um die vollen Zahlen zu zeigen
      const lastEntry = filteredStatusData[filteredStatusData.length - 1];
      const archiveCount = parseInt(lastEntry['Archiv'] || 0);
      const errorCount = parseInt(lastEntry['Error'] || 0);
      
      let ratio;
      if (errorCount === 0 && archiveCount === 0) {
        ratio = "N/A";
      } else if (errorCount === 0) {
        ratio = "∞";
      } else if (archiveCount === 0) {
        ratio = "0:1";
      } else {
        // Verwende vollständige Zahlen statt gekürzter Verhältnisse
        ratio = archiveCount + ":" + errorCount;
      }
      
      document.getElementById('archiveToErrorRatio').textContent = ratio;
    }

    // Fehler-Trend nach Typ erstellen
    function createErrorTrendChart() {
      if (filteredPatternData.length === 0) return;
      
      // Get the timeframe text directly for consistency
      const timeframeText = document.getElementById('timeframeDisplay').textContent;
      
      // Get the current timeframe dates
      const startDate = new Date(document.getElementById('startDate').value + 'T' + (document.getElementById('startTime').value || '00:00'));
      const endDate = new Date(document.getElementById('endDate').value + 'T' + (document.getElementById('endTime').value || '00:00'));
      
      // Get appropriate aggregation settings based on the timeframe
      const aggregation = getAggregationInterval(startDate, endDate);
      
      // Group errors by interval and pattern
      const errorTypesByInterval = {};
      const errorTypes = new Set();
      
      filteredPatternData.forEach(entry => {
        if (!entry.Zeitpunkt) return;
        
        // Extract timestamp and round to appropriate interval
        const timestamp = new Date(entry.Zeitpunkt);
        const intervalKey = aggregation.roundFn(timestamp).toISOString();
        const displayLabel = aggregation.format(timestamp);
        const pattern = entry.Muster;
        
        if (!errorTypesByInterval[intervalKey]) {
          errorTypesByInterval[intervalKey] = {
            displayLabel: displayLabel,
            patterns: {}
          };
        }
        
        if (!errorTypesByInterval[intervalKey].patterns[pattern]) {
          errorTypesByInterval[intervalKey].patterns[pattern] = 0;
        }
        
        errorTypesByInterval[intervalKey].patterns[pattern]++;
        errorTypes.add(pattern);
      });
      
      // Prepare data for Chart.js
      const sortedKeys = Object.keys(errorTypesByInterval).sort();
      const labels = sortedKeys.map(key => errorTypesByInterval[key].displayLabel);
      
      // Colors for different error types
      const colors = [
        'rgba(255, 99, 132, 1)',
        'rgba(54, 162, 235, 1)',
        'rgba(255, 206, 86, 1)',
        'rgba(75, 192, 192, 1)',
        'rgba(153, 102, 255, 1)',
        'rgba(255, 159, 64, 1)'
      ];
      
      // Create datasets
      const datasets = [];
      
      // Create a dataset for each error type
      Array.from(errorTypes).forEach((type, index) => {
        const data = sortedKeys.map(key => errorTypesByInterval[key].patterns[type] || 0);
        
        datasets.push({
          type: 'line',
          label: type,
          data: data,
          borderColor: colors[index % colors.length],
          backgroundColor: colors[index % colors.length].replace('1)', '0.2)'),
          tension: 0.3,
          fill: true,
          pointRadius: 0,
          pointHoverRadius: 3
        });
      });
      
      // Determine appropriate axis label based on the aggregation interval
      let xAxisLabel = '';
      switch(aggregation.interval) {
        case 'hour': xAxisLabel = 'Stunde'; break;
        case 'day': xAxisLabel = 'Tag'; break;
        case 'week': xAxisLabel = 'Woche'; break;
        default: xAxisLabel = 'Zeitraum';
      }
      
      // Create chart
      const ctx = document.getElementById('errorTrendChart').getContext('2d');
      if (window.errorTrendChart instanceof Chart) {
        window.errorTrendChart.destroy();
      }
      
      window.errorTrendChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              stacked: true,
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Fehler'
              }
            },
            x: {
              stacked: true,
              title: {
                display: true,
                text: `${xAxisLabel} (${timeframeText})`
              },
              ticks: {
                maxRotation: 45,
                minRotation: 45
              }
            }
          },
          plugins: {
            title: {
              display: true,
              text: `Fehlertypen-Verlauf (${timeframeText})`,
              font: {
                size: 16
              }
            },
            tooltip: {
              mode: 'index',
              callbacks: {
                title: function(context) {
                  return context[0].label;
                }
              }
            }
          }
        }
      });
    }

    // Fehlerrate-Diagramm erstellen
    function createErrorRateChart() {
      if (filteredStatusData.length === 0) return;
      
      // Get the timeframe text directly for consistency
      const timeframeText = document.getElementById('timeframeDisplay').textContent;
      
      // Get the current timeframe dates
      const startDate = new Date(document.getElementById('startDate').value + 'T' + (document.getElementById('startTime').value || '00:00'));
      const endDate = new Date(document.getElementById('endDate').value + 'T' + (document.getElementById('endTime').value || '00:00'));
      
      // Get appropriate aggregation settings based on the timeframe
      const aggregation = getAggregationInterval(startDate, endDate);
      
      // Group data by the determined interval
      const errorRateByInterval = {};
      
      // Sort data points chronologically
      filteredStatusData.sort((a, b) => new Date(a.Zeitpunkt) - new Date(b.Zeitpunkt));
      
      filteredStatusData.forEach(entry => {
        if (!entry.Zeitpunkt) return;
        
        // Extract date and round to appropriate interval
        const timestamp = new Date(entry.Zeitpunkt);
        const intervalKey = aggregation.roundFn(timestamp).toISOString();
        
        // Calculate error rate for this entry
        const processed = parseInt(entry['Archiv'] || 0) + parseInt(entry['Error'] || 0);
        const errorFiles = parseInt(entry['Error'] || 0);
        const errorRate = processed > 0 ? (errorFiles / processed) * 100 : 0;
        
        // Store or update the interval error rate
        if (!errorRateByInterval[intervalKey]) {
          errorRateByInterval[intervalKey] = {
            count: 0,
            sum: 0,
            timestamp: timestamp
          };
        }
        
        errorRateByInterval[intervalKey].sum += errorRate;
        errorRateByInterval[intervalKey].count++;
      });
      
      // Calculate average error rate for each interval
      const labels = [];
      const data = [];
      
      Object.entries(errorRateByInterval)
        .sort(([a], [b]) => a.localeCompare(b)) // Sort by timestamp
        .forEach(([intervalKey, values]) => {
          labels.push(aggregation.format(values.timestamp));
          data.push((values.sum / values.count).toFixed(1)); // Format to 1 decimal place
        });
      
      // Create the chart
      const ctx = document.getElementById('errorRateChart').getContext('2d');
      if (window.errorRateChart instanceof Chart) {
        window.errorRateChart.destroy();
      }
      
      // Determine appropriate axis labels based on the aggregation interval
      let xAxisLabel = '';
      switch(aggregation.interval) {
        case 'hour': xAxisLabel = 'Stunde'; break;
        case 'day': xAxisLabel = 'Tag'; break;
        case 'week': xAxisLabel = 'Woche'; break;
        default: xAxisLabel = 'Zeitraum';
      }
      
      window.errorRateChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Fehlerrate (%)',
            data: data,
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 2,
            tension: 0.3,
            fill: true,
            pointRadius: 3,
            pointHoverRadius: 5
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Fehlerrate (%)'
              }
            },
            x: {
              title: {
                display: true,
                text: `${xAxisLabel} (${timeframeText})` // Dynamic label with timeframe
              },
              ticks: {
                maxRotation: 45,
                minRotation: 45
              }
            }
          },
          plugins: {
            title: {
              display: true,
              text: `Fehlerrate-Verlauf (${timeframeText})`, // Add timeframe to chart title
              font: {
                size: 16
              }
            },
            tooltip: {
              callbacks: {
                title: function(context) {
                  return context[0].label;
                },
                label: function(context) {
                  return `Fehlerrate: ${context.raw}%`;
                }
              }
            }
          }
        }
      });
    }

    // Durchsatz-Diagramm erstellen
    function createThroughputChart() {
      if (filteredStatusData.length <= 1) {
        console.log("Not enough data for throughput chart");
        return;
      }
      
      // Get the current timeframe for display and dynamic aggregation
      const startDate = new Date(document.getElementById('startDate').value + 'T' + (document.getElementById('startTime').value || '00:00'));
      const endDate = new Date(document.getElementById('endDate').value + 'T' + (document.getElementById('endTime').value || '00:00'));
      const timeframeText = document.getElementById('timeframeDisplay').textContent;
      
      // Get appropriate aggregation settings based on the timeframe
      const aggregation = getAggregationInterval(startDate, endDate);
      
      // Group data by the determined interval
      const throughputByInterval = {};
      let prevProcessed = null;
      let prevTimestamp = null;
      
      // Process data points in chronological order
      filteredStatusData.sort((a, b) => new Date(a.Zeitpunkt) - new Date(b.Zeitpunkt));
      
      filteredStatusData.forEach(entry => {
        if (!entry.Zeitpunkt) return;
        
        // Extract date and round to appropriate interval
        const timestamp = new Date(entry.Zeitpunkt);
        const intervalKey = aggregation.roundFn(timestamp).toISOString();
        
        // Calculate total processed files (archive + error)
        const processed = parseInt(entry['Archiv'] || 0) + parseInt(entry['Error'] || 0);
        
        // If we have previous data, calculate the throughput
        if (prevProcessed !== null && prevTimestamp !== null) {
          const hoursDiff = (timestamp - prevTimestamp) / (1000 * 60 * 60);
          if (hoursDiff > 0) {
            const filesDiff = processed - prevProcessed;
            // Only record positive throughput (files being processed)
            if (filesDiff > 0) {
              const throughputPerHour = Math.round(filesDiff / hoursDiff);
              
              // Store or update the interval throughput
              if (!throughputByInterval[intervalKey]) {
                throughputByInterval[intervalKey] = {
                  count: 0,
                  sum: 0,
                  timestamp: timestamp
                };
              }
              
              throughputByInterval[intervalKey].sum += throughputPerHour;
              throughputByInterval[intervalKey].count++;
            }
          }
        }
        
        prevProcessed = processed;
        prevTimestamp = timestamp;
      });
      
      // Calculate average throughput for each interval
      const labels = [];
      const data = [];
      
      Object.entries(throughputByInterval)
        .sort(([a], [b]) => a.localeCompare(b)) // Sort by timestamp
        .forEach(([intervalKey, values]) => {
          labels.push(aggregation.format(values.timestamp));
          data.push(Math.round(values.sum / values.count));
        });
      
      // Create the chart
      const ctx = document.getElementById('throughputChart').getContext('2d');
      if (window.throughputChart instanceof Chart) {
        window.throughputChart.destroy();
      }
      
      // Determine appropriate axis labels based on the aggregation interval
      let xAxisLabel = '';
      switch(aggregation.interval) {
        case 'hour': xAxisLabel = 'Stunde'; break;
        case 'day': xAxisLabel = 'Tag'; break;
        case 'week': xAxisLabel = 'Woche'; break;
        default: xAxisLabel = 'Zeitraum';
      }
      
      window.throughputChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Dateien pro Stunde',
            data: data,
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 2,
            tension: 0.3,
            fill: true,
            pointRadius: 3,
            pointHoverRadius: 5
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Durchsatz (Dateien/Stunde)'
              }
            },
            x: {
              title: {
                display: true,
                text: `${xAxisLabel} (${timeframeText})` // Dynamic label with timeframe
              },
              ticks: {
                maxRotation: 45,
                minRotation: 45
              }
            }
          },
          plugins: {
            title: {
              display: true,
              text: `Durchsatz-Verlauf (${timeframeText})`, // Add timeframe to chart title
              font: {
                size: 16
              }
            },
            tooltip: {
              callbacks: {
                title: function(context) {
                  return context[0].label;
                },
                label: function(context) {
                  return `Durchsatz: ${context.raw} Dateien/Stunde`;
                }
              }
            }
          }
        }
      });
    }

    // Fehler nach Stunde erstellen
    function createErrorsByHourChart() {
      if (filteredErrorData.length === 0) return;
      
      // Fehler nach Stunde gruppieren
      const errorsByHour = Array(24).fill(0);
      
      filteredErrorData.forEach(entry => {
        if (entry.Zeitpunkt) {
          const hour = parseInt(entry.Zeitpunkt.split(' ')[1].split(':')[0]);
          if (!isNaN(hour) && hour >= 0 && hour < 24) {
            errorsByHour[hour]++;
          }
        }
      });
      
      // Labels erstellen (0-23 Uhr)
      const labels = Array.from({length: 24}, (_, i) => `${i}:00`);
      
      // Chart erstellen
      const ctx = document.getElementById('errorsByHourChart').getContext('2d');
      if (window.errorsByHourChart instanceof Chart) {
        window.errorsByHourChart.destroy();
      }
      
      window.errorsByHourChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Fehler pro Stunde',
            data: errorsByHour,
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Fehler'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Stunde des Tages'
              }
            }
          }
        }
      });
    }

    // Fehler nach Wochentag erstellen
    function createErrorsByWeekdayChart() {
      if (filteredErrorData.length === 0) {
        console.log("Keine Fehlerdaten für Wochentag-Chart verfügbar");
        return;
      }
        // Fehler nach Wochentag gruppieren
      const errorsByWeekday = Array(7).fill(0);
      
      filteredErrorData.forEach(entry => {
        if (entry.Zeitpunkt) {
          try {
            const [datePart] = entry.Zeitpunkt.split(' ');
            const [year, month, day] = datePart.split('-').map(num => parseInt(num));
            const date = new Date(year, month-1, day);
            const weekday = date.getDay(); // 0 = Sonntag, 1 = Montag, ...
            // Konvertieren von Sonntag=0, Montag=1, ... zu Montag=0, Dienstag=1, ... Sonntag=6
            const mondayStartWeekday = weekday === 0 ? 6 : weekday - 1;
            if (mondayStartWeekday >= 0 && mondayStartWeekday < 7) {
              errorsByWeekday[mondayStartWeekday]++;
            } else {
              console.warn("Ungültiger Wochentag:", mondayStartWeekday, "für Datum:", entry.Zeitpunkt);
            }
          } catch (e) {
            console.error("Fehler bei der Verarbeitung des Datums:", entry.Zeitpunkt, e);
          }
        }
      });
      
      console.log("Fehler nach Wochentag:", errorsByWeekday);
      
      // Wochentagsnamen, startend mit Montag
      const weekdays = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag', 'Sonntag'];
      
      const ctx = document.getElementById('errorsByWeekdayChart');
      
      if (!ctx) {
        console.error("Canvas-Element 'errorsByWeekdayChart' nicht gefunden!");
        return;
      }
      
      // Chart erstellen
      try {
        if (window.errorsByWeekdayChart instanceof Chart) {
          window.errorsByWeekdayChart.destroy();
        }
        
        window.errorsByWeekdayChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: weekdays,
            datasets: [{
              label: 'Fehler pro Wochentag',
              data: errorsByWeekday,
              backgroundColor: 'rgba(153, 102, 255, 0.2)',
              borderColor: 'rgba(153, 102, 255, 1)',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Anzahl der Fehler'
                }
              },
              x: {
                title: {
                  display: true,
                  text: 'Wochentag'
                }
              }
            }
          }
        });
      } catch (error) {
        console.error("Fehler beim Erstellen des Fehler-nach-Wochentag-Diagramms:", error);
      }
    }    // Fehlertypen nach Wochentag als gestapeltes Balkendiagramm
    function createErrorsByWeekdayStackedChart() {
      // Genau dieselbe Logik wie bei updateTopErrorsList() verwenden
      if (filteredPatternData.length === 0) return;
      
      // Bestehendes Diagramm zerstören, falls vorhanden
      if (window.errorsByWeekdayChart instanceof Chart) {
        window.errorsByWeekdayChart.destroy();
        window.errorsByWeekdayChart = null;
      }
      
      const ctx = document.getElementById('errorHeatmapChart').getContext('2d');
      
      // Fehler nach Muster gruppieren und zählen, genau wie bei der Top-Fehler-Liste
      const errorsByType = {};
      filteredPatternData.forEach(entry => {
        const pattern = entry.Muster;
        if (!errorsByType[pattern]) {
          errorsByType[pattern] = {
            total: 0,
            byWeekday: [0, 0, 0, 0, 0, 0, 0]  // Mo, Di, Mi, Do, Fr, Sa, So
          };
        }
        
        // Gesamtzahl für den Fehlertyp erhöhen
        errorsByType[pattern].total++;
        
        // Wochentag bestimmen und entsprechenden Zähler erhöhen
        if (entry.Zeitpunkt) {
          const [datePart] = entry.Zeitpunkt.split(' ');
          const [year, month, day] = datePart.split('-').map(num => parseInt(num));
          const date = new Date(year, month - 1, day);
          const weekday = date.getDay(); // 0 = Sonntag, 1 = Montag, ...
          // Konvertieren von Sonntag=0, Montag=1, ... zu Montag=0, Dienstag=1, ... Sonntag=6
          const mondayStartWeekday = weekday === 0 ? 6 : weekday - 1;
          errorsByType[pattern].byWeekday[mondayStartWeekday]++;
        }
      });
      
      // Nach Gesamtzahl sortieren, genau wie bei der Top-Fehler-Liste
      const sortedErrors = Object.entries(errorsByType)
        .sort((a, b) => b[1].total - a[1].total);
      
      console.log("Fehlerverteilung nach Muster:", sortedErrors);
      
      // Bis zu 10 häufigste Fehler für das Diagramm verwenden
      const topErrors = sortedErrors.slice(0, 10);
      const labels = topErrors.map(err => err[0]); // Fehlermuster
        // Transformiere die Daten für das gestapelte Balkendiagramm
      // (7 Wochentage x bis zu 10 Fehlertypen)
      const weekdays = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag', 'Sonntag'];
      const datasets = [];
      
      // Kräftigere Farben für die Fehlertypen
      const colors = [
        'rgba(102, 153, 204, 0.85)',   // Kräftigeres Blau
        'rgba(140, 140, 140, 0.85)',   // Dunkleres Grau
        'rgba(120, 177, 120, 0.85)',   // Kräftigeres Grün
        'rgba(204, 120, 120, 0.85)',   // Kräftigeres Rosa
        'rgba(160, 120, 204, 0.85)',   // Kräftigeres Lila
        'rgba(204, 180, 80, 0.85)',    // Kräftigeres Gelb
        'rgba(80, 180, 204, 0.85)',    // Kräftigeres Türkis
        'rgba(194, 135, 80, 0.85)',    // Kräftigeres Hellbraun
        'rgba(110, 150, 204, 0.85)',   // Kräftigeres Hellblau
        'rgba(204, 160, 110, 0.85)'    // Kräftigeres Sand
      ];
      
      // Für jeden Fehlertyp ein Dataset erstellen
      topErrors.forEach((error, index) => {
        const [errorType, data] = error;
        const color = colors[index % colors.length]; // Verwende die kräftigeren Farben
        
        datasets.push({
          label: errorType,
          data: data.byWeekday,
          backgroundColor: color,
          borderColor: color.replace('0.85)', '1)'),
          borderWidth: 1
        });
      });
      
      try {
        // Erzeuge ein gestapeltes Balkendiagramm für die Fehlerverteilung nach Wochentag
        window.errorsByWeekdayChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: weekdays,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                title: {
                  display: true,
                  text: 'Wochentag'
                },
                stacked: true
              },
              y: {
                title: {
                  display: true,
                  text: 'Anzahl der Fehler'
                },
                stacked: true,
                beginAtZero: true
              }
            },
            plugins: {
              title: {
                display: true,
                text: 'Fehlertypen nach Wochentagen',
                font: {
                  size: 16
                }
              },
              tooltip: {
                callbacks: {
                  title: function(context) {
                    return context[0].label;
                  },
                  label: function(context) {
                    const label = context.dataset.label || '';
                    const value = context.raw || 0;
                    return `${label}: ${value} Fehler`;
                  },
                  footer: function(context) {
                    // Summe aller Fehler für diesen Wochentag anzeigen
                    const weekdayIndex = context[0].dataIndex;
                    let total = 0;
                    context.forEach(item => {
                      total += item.raw || 0;
                    });
                    return `Gesamt: ${total} Fehler`;
                  }
                }
              }
            }
          }
        });
      } catch (error) {
        console.error("Fehler beim Erstellen des Fehlertypen-Wochentag-Diagramms:", error);
      }
    }

    // Top Fehler-Liste aktualisieren
    function updateTopErrorsList() {
      const container = document.getElementById('topErrorsList');
      if (!container || filteredPatternData.length === 0) {
        if (container) container.innerHTML = 'Keine Daten verfügbar';
        return;
      }
      
      // Fehler nach Muster gruppieren und zählen
      const errorsByType = {};
      
      filteredPatternData.forEach(entry => {
        const pattern = entry.Muster;
        
        if (!errorsByType[pattern]) {
          errorsByType[pattern] = 0;
        }
        
        errorsByType[pattern]++;
      });
      
      // Nach Anzahl sortieren und die Top 10 nehmen
      const sortedErrors = Object.entries(errorsByType)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      // HTML für die Liste erstellen
      const html = sortedErrors.map((error, index) => {
        return `
          <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
            <div>${index + 1}. ${error[0]}</div>
            <div><strong>${error[1]}</strong></div>
          </div>
        `;
      }).join('');
      
      container.innerHTML = html || 'Keine Fehler gefunden';
    }

    // System-Gesundheit Gauge aktualisieren
    function updateSystemHealthGauge() {
    if (filteredStatusData.length === 0) return;
    
    // Use the central error rate calculation function
    const errorRateString = calculateErrorRate();
    
    // Parse the error rate from the returned string (removes the % sign)
    const errorRateValue = parseFloat(errorRateString) || 0;
    
    // Gesundheit berechnen: 100% - Fehlerrate
    const healthPercentage = Math.max(0, 100 - errorRateValue);
    
    // Gesundheitspunktzahl anzeigen
    document.getElementById('healthScore').textContent = healthPercentage.toFixed(1) + '%';
    
    // Rest of the gauge creation code remains unchanged
    const ctx = document.getElementById('healthGauge').getContext('2d');
    if (window.healthGauge instanceof Chart) {
      window.healthGauge.destroy();
    }
    
    // Farbe basierend auf Gesundheit
    let color = 'rgba(75, 192, 192, 1)'; // Grün
    if (healthPercentage < 90) {
      color = 'rgba(255, 206, 86, 1)'; // Gelb
    }
    if (healthPercentage < 80) {
      color = 'rgba(255, 99, 132, 1)'; // Rot
    }
    
  window.healthGauge = new Chart(ctx, {
        type: 'doughnut',
        data: {
          datasets: [{
            data: [healthPercentage, 100 - healthPercentage],
            backgroundColor: [
              color,
              'rgba(200, 200, 200, 0.2)'
            ],
            circumference: 180,
            rotation: 270
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutout: '70%',
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              enabled: false
            }
          }
        }
      });
    }

    // Tabelle rendern
    function renderTable(data, containerId, highlightErrors = false) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';

      if (!data || data.length === 0) {
        container.innerHTML = '<p>Keine Daten verfügbar.</p>';
        return;
      }

      // Tabelle erstellen
      const table = document.createElement('table');
      table.className = 'mdl-data-table mdl-js-data-table mdl-shadow--2dp';
      
      // Header erstellen
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      
      // Spaltenüberschriften aus dem ersten Datensatz
      const headers = Object.keys(data[0]);
      headers.forEach(header => {
        const th = document.createElement('th');
        th.className = 'mdl-data-table__cell--non-numeric';
        th.textContent = header;
        headerRow.appendChild(th);
      });
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Tabellenkörper erstellen
      const tbody = document.createElement('tbody');
      
      // Nur die letzten 100 Einträge anzeigen, um die Leistung zu verbessern
      const displayData = data.length > 100 ? data.slice(-100) : data;
      
      displayData.forEach(row => {
        const tr = document.createElement('tr');
        
        // Zeile hervorheben, wenn sie einen Fehler enthält
        if (highlightErrors && row.Muster) {
          tr.className = 'error-card';
        }
        
        headers.forEach(header => {
          const td = document.createElement('td');
          td.className = 'mdl-data-table__cell--non-numeric';
          
          // Text kürzen, wenn er zu lang ist
          let content = row[header] || '';
          
          // Behandlung für die Dateinamen-Spalte
          if (header === 'Dateinamen als String' && content.length > 100) {
            // Anzahl der Dateien ermitteln
            const fileCount = content.split(',').length;
            // Nur die ersten 3 Dateien anzeigen
            const firstFiles = content.split(',').slice(0, 3).join(', ');
            content = firstFiles + ` ... (${fileCount} Dateien insgesamt)`;
          } else if (content.length > 100) {
            content = content.substring(0, 100) + '...';
          }
          
          // Fehlermuster hervorheben
          if (header === 'Fehlermeldung' || header === 'Text') {
            const patternContainer = document.createElement('div');
            let textContent = content;
            
            // Bekannte Fehlermuster markieren
            knownErrorPatterns.forEach(pattern => {
              if (content.includes(pattern)) {
                const badge = document.createElement('span');
                badge.className = 'pattern-badge';
                badge.textContent = pattern;
                patternContainer.appendChild(badge);
                
                // Muster im Text ersetzen, damit es nicht doppelt angezeigt wird
                textContent = textContent.replace(pattern, '');
              }
            });
            
            // Nur den Text hinzufügen, wenn nach den Badges noch Text übrig ist
            if (textContent.trim()) {
              const textSpan = document.createElement('div');
              textSpan.className = 'pattern-container';
              textSpan.textContent = textContent;
              patternContainer.appendChild(textSpan);
            }
            
            td.appendChild(patternContainer);
          } else {
            td.textContent = content;
          }
          
          tr.appendChild(td);
        });
        
        tbody.appendChild(tr);
      });
      
      table.appendChild(tbody);
      container.appendChild(table);
      
      // MDL-Komponenten aktualisieren
      if (typeof componentHandler !== 'undefined') {
        componentHandler.upgradeElement(table);
      }
    }

    // Fehler-Typ-Kuchendiagramm erstellen
    function createErrorTypePieChart() {
      if (filteredPatternData.length === 0) return;
      
      // Fehler nach Muster gruppieren
      const errorsByType = {};
      
      filteredPatternData.forEach(entry => {
        const pattern = entry.Muster;
        
        if (!errorsByType[pattern]) {
          errorsByType[pattern] = 0;
        }
        
        errorsByType[pattern]++;
      });
      
      // Nach Häufigkeit sortieren
      const sortedErrors = Object.entries(errorsByType)
        .sort((a, b) => b[1] - a[1]);
      
      // Alle Fehlertypen anzeigen
      const labels = [];
      const data = [];
      
      // Dynamisch Farben für beliebig viele Einträge erstellen
      const generateColors = (count) => {
        const colors = [];
        const baseColors = [
          'rgba(255, 99, 132, 0.7)',
          'rgba(54, 162, 235, 0.7)',
          'rgba(255, 206, 86, 0.7)',
          'rgba(75, 192, 192, 0.7)',
          'rgba(153, 102, 255, 0.7)',
          'rgba(255, 159, 64, 0.7)',
          'rgba(201, 203, 207, 0.7)',
          'rgba(119, 221, 119, 0.7)',
          'rgba(179, 106, 200, 0.7)',
          'rgba(225, 123, 36, 0.7)'
        ];
        
        // Verwende die Basisfarben für die ersten Einträge
        for (let i = 0; i < count; i++) {
          if (i < baseColors.length) {
            colors.push(baseColors[i]);
          } else {
            // Für weitere Einträge generiere Farben basierend auf Position
            const hue = (i * 137.508) % 360; // Goldener Schnitt für gute Farbverteilung
            colors.push(`hsla(${hue}, 70%, 60%, 0.7)`);
          }
        }
        
        return colors;
      };
      
      sortedErrors.forEach((error) => {
        labels.push(error[0]);
        data.push(error[1]);
      });
      
      // Chart erstellen
      const ctx = document.getElementById('errorTypePieChart').getContext('2d');
      if (window.errorTypePieChart instanceof Chart) {
        window.errorTypePieChart.destroy();
      }
      
      window.errorTypePieChart = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            data: data,
            backgroundColor: generateColors(labels.length),
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: {
                boxWidth: 15,
                font: {
                  size: 11
                }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const label = context.label || '';
                  const value = context.raw || 0;
                  const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                  const percentage = ((value / total) * 100).toFixed(1);
                  return `${label}: ${value} (${percentage}%)`;
                }
              }
            }
          }
        }
      });
    }

    // Duplicate chart for the Overview tab
    function createErrorsByWeekdayStackedChart2() {
      // Check if container exists
      const ctx = document.getElementById('errorsByWeekdayStackedChart2');
      if (!ctx) {
        console.error("Canvas-Element 'errorsByWeekdayStackedChart2' nicht gefunden!");
        return;
      }

      // Destroy existing chart if any
      if (window.errorsByWeekdayStackedChart2 instanceof Chart) {
        window.errorsByWeekdayStackedChart2.destroy();
      }
      
      if (filteredPatternData.length === 0) {
        console.log("Keine Muster-Daten für das Wochentag-Stacked-Chart verfügbar");
        return;
      }
      
      // Fehler nach Muster gruppieren und zählen
      const errorsByType = {};      filteredPatternData.forEach(entry => {
        const pattern = entry.Muster;
        if (!errorsByType[pattern]) {
          errorsByType[pattern] = {
            total: 0,
            byWeekday: [0, 0, 0, 0, 0, 0, 0]  // Mo, Di, Mi, Do, Fr, Sa, So
          };
        }
        
        // Gesamtzahl für den Fehlertyp erhöhen
        errorsByType[pattern].total++;
        
        // Wochentag bestimmen und entsprechenden Zähler erhöhen
        if (entry.Zeitpunkt) {
          const [datePart] = entry.Zeitpunkt.split(' ');
          const [year, month, day] = datePart.split('-').map(num => parseInt(num));
          const date = new Date(year, month - 1, day);
          const weekday = date.getDay(); // 0 = Sonntag, 1 = Montag, ...
          // Konvertieren von Sonntag=0, Montag=1, ... zu Montag=0, Dienstag=1, ... Sonntag=6
          const mondayStartWeekday = weekday === 0 ? 6 : weekday - 1;
          errorsByType[pattern].byWeekday[mondayStartWeekday]++;
        }
      });
      
      // Nach Gesamtzahl sortieren
      const sortedErrors = Object.entries(errorsByType)
        .sort((a, b) => b[1].total - a[1].total);
      
      // Top 10 häufigste Fehler verwenden
      const topErrors = sortedErrors.slice(0, 10);
        // Wochentagsnamen, startend mit Montag
      const weekdays = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag', 'Sonntag'];
      const datasets = [];
      
      // Kräftige Farben für die Fehlertypen
      const colors = [
        'rgba(102, 153, 204, 0.85)',   // Kräftigeres Blau
        'rgba(140, 140, 140, 0.85)',   // Dunkleres Grau
        'rgba(120, 177, 120, 0.85)',   // Kräftigeres Grün
        'rgba(204, 120, 120, 0.85)',   // Kräftigeres Rosa
        'rgba(160, 120, 204, 0.85)',   // Kräftigeres Lila
        'rgba(204, 180, 80, 0.85)',    // Kräftigeres Gelb
        'rgba(80, 180, 204, 0.85)',    // Kräftigeres Türkis
        'rgba(194, 135, 80, 0.85)',    // Kräftigeres Hellbraun
        'rgba(110, 150, 204, 0.85)',   // Kräftigeres Hellblau
        'rgba(204, 160, 110, 0.85)'    // Kräftigeres Sand
      ];
      
      // Für jeden Fehlertyp ein Dataset erstellen
      topErrors.forEach((error, index) => {
        const [errorType, data] = error;
        const color = colors[index % colors.length];
        
        datasets.push({
          label: errorType,
          data: data.byWeekday,
          backgroundColor: color,
          borderColor: color.replace('0.85)', '1)'),
          borderWidth: 1
        });
      });
      
      try {
        // Gestapeltes Balkendiagramm erstellen
        window.errorsByWeekdayStackedChart2 = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: weekdays,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                title: {
                  display: true,
                  text: 'Wochentag'
                },
                stacked: true
              },
              y: {
                title: {
                  display: true,
                  text: 'Anzahl der Fehler'
                },
                stacked: true,
                beginAtZero: true
              }
            },
            plugins: {
              tooltip: {
                callbacks: {
                  title: function(context) {
                    return context[0].label;
                  },
                  label: function(context) {
                    const label = context.dataset.label || '';
                    const value = context.raw || 0;
                    return `${label}: ${value} Fehler`;
                  },
                  footer: function(context) {
                    // Summe aller Fehler für diesen Wochentag anzeigen
                    const weekdayIndex = context[0].dataIndex;
                    let total = 0;
                    context.forEach(item => {
                      total += item.raw || 0;
                    });
                    return `Gesamt: ${total} Fehler`;
                  }
                }
              }
            }
          }
        });
      } catch (error) {
        console.error("Fehler beim Erstellen des zweiten Fehlertypen-Wochentag-Diagramms:", error);
      }
    }    // Quick Filter anwenden
    function applyQuickFilter(amount, unit) {
      // Aktuelle Zeit für das Enddatum
      const now = new Date();
      
      // Set seconds and milliseconds to zero for precise time periods
      now.setSeconds(0, 0);
      
      const endDate = new Date(now);
      
      // Startdatum berechnen
      const startDate = new Date(now);
      if (unit === 'minute') {
        startDate.setMinutes(startDate.getMinutes() - amount);
      } else if (unit === 'hour') {
        startDate.setHours(startDate.getHours() - amount);
      } else if (unit === 'day') {
        startDate.setDate(startDate.getDate() - amount);
      }
      
      // Formatieren für die Eingabefelder
      const startDateStr = startDate.toISOString().split('T')[0];
      const startTimeStr = `${startDate.getHours().toString().padStart(2, '0')}:${startDate.getMinutes().toString().padStart(2, '0')}`;
      
      const endDateStr = endDate.toISOString().split('T')[0];
      const endTimeStr = `${endDate.getHours().toString().padStart(2, '0')}:${endDate.getMinutes().toString().padStart(2, '0')}`;
      
      // Werte setzen
      document.getElementById('startDate').value = startDateStr;
      document.getElementById('startTime').value = startTimeStr;
      document.getElementById('endDate').value = endDateStr;
      document.getElementById('endTime').value = endTimeStr;
      
      // Anzeigewerte aktualisieren
      updateDateDisplay('startDate');
      updateTimeDisplay('startTime');
      updateDateDisplay('endDate');
      updateTimeDisplay('endTime');
      
      // Set the filter variables directly for more precise control
      startDateFilter = new Date(startDate);
      endDateFilter = new Date(endDate);
      // No need to add seconds to endDateFilter since we zeroed them out
      
      // Apply filters and process data
      applyFilters();
      processAllData();
      
      // Update the slider if it exists
      if (window.dateSlider) {
        window.dateSlider.set([startDateFilter.getTime(), endDateFilter.getTime()]);
      }
      
      // Update the timeframe display
      updateTimeframeDisplay();
      
      // Feedback für den Benutzer als Konsolen-Log
      console.log(`Filter angewendet: Letzte ${amount} ${getUnitText(amount, unit)}`);
    }

    // Hilfsfunktion für die richtige Pluralform
    function getUnitText(amount, unit) {
      if (unit === 'minute') {
        return amount === 1 ? 'Minute' : 'Minuten';
      } else if (unit === 'hour') {
        return amount === 1 ? 'Stunde' : 'Stunden';
      } else if (unit === 'day') {
        return amount === 1 ? 'Tag' : 'Tage';
      }
      return '';
    }

    // Initial alle Daten laden
    loadConfig();
    
    // Datumsfilter initialisieren
    initDateFilter();
    
    // Auto-refresh Funktionalität
    function toggleAutoRefresh() {
      const button = document.getElementById('autoRefreshToggle');
      const statusText = button.querySelector('.auto-refresh-status');
      
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
        button.setAttribute('data-state', 'off');
        statusText.textContent = 'OFF';
      } else {
        autoRefreshInterval = setInterval(loadAllData, 300000); // 5 Minuten (300000ms)
        button.removeAttribute('data-state');
        statusText.textContent = 'ON';
      }
    }
    
    // Auto-refresh beim Start aktivieren
    autoRefreshInterval = setInterval(loadAllData, 300000); // 5 Minuten

    // Theme-Toggle-Button Funktionalität
    document.getElementById('themeToggle').addEventListener('change', function() {
      if (this.checked) {
        document.documentElement.setAttribute('data-theme', 'dark');
      } else {
        document.documentElement.setAttribute('data-theme', 'light');
      }
    });    // Initialize theme based on system preference and then checkbox state
    document.addEventListener('DOMContentLoaded', function() {
      const themeToggle = document.getElementById('themeToggle');
      if (themeToggle) {
        // Check system preference first
        const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        // Set checkbox state based on system preference
        themeToggle.checked = prefersDarkScheme;
        
        // Apply theme based on the checkbox state (which now reflects system preference)
        document.documentElement.setAttribute('data-theme', themeToggle.checked ? 'dark' : 'light');
        
        // Listen for system preference changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
          themeToggle.checked = e.matches;
          document.documentElement.setAttribute('data-theme', e.matches ? 'dark' : 'light');
        });
      }
      
      // Initialize filter collapse state from localStorage
      const filterContent = document.getElementById('filterContent');
      const filterHeader = document.querySelector('.filter-header');
      const toggleIcon = document.getElementById('toggleFilterIcon');
      const toggleButton = document.getElementById('toggleFilterBtn');
      
      if (filterContent && filterHeader && toggleIcon && toggleButton) {
        // Check if we have a saved preference
        const isCollapsed = localStorage.getItem('filterCollapsed') === 'true';
        
        // Apply the saved state
        if (isCollapsed) {
          filterContent.classList.add('collapsed');
          filterHeader.classList.add('collapsed');
          toggleIcon.textContent = 'expand_more';
        }
        
        // Add click handler to toggle button
        toggleButton.addEventListener('click', toggleFilter);
        
        // Also allow clicking anywhere on the header to toggle
        filterHeader.addEventListener('click', function(e) {
          // Only toggle if the click wasn't on a button inside the header
          if (e.target !== toggleButton && !toggleButton.contains(e.target)) {
            toggleFilter();
          }
        });
      }
      
      // Initialize card collapse states from localStorage
      const cardIds = ['healthCard', 'errorDistributionCard', 'topErrorsCard'];
      cardIds.forEach(cardId => {
        const card = document.getElementById(cardId);
        if (card) {
          const cardContent = card.querySelector('.mdl-card__supporting-text');
          const toggleIcon = card.querySelector('.toggle-card-btn i');
          
          if (cardContent && toggleIcon) {
            // Check for saved state
            const isCollapsed = localStorage.getItem(`card_${cardId}_collapsed`) === 'true';
            
            // Apply saved state
            if (isCollapsed) {
              cardContent.classList.add('collapsed');
              toggleIcon.textContent = 'expand_more';
            }
          }
        }
      });
      
      // Initialize the range slider after data is loaded (if not already initialized)
      if (allStatusData.length > 0) {
        initDateRangeSlider();
      }
    });

    // Datum anpassen
    function adjustDate(inputId, amount, unit) {
      const input = document.getElementById(inputId);
      if (!input || !input.value) return;

      const currentDate = new Date(input.value);
      if (unit === 'day') {
        currentDate.setDate(currentDate.getDate() + amount);
      } else if (unit === 'month') {
        currentDate.setMonth(currentDate.getMonth() + amount);
      } else if (unit === 'year') {
        currentDate.setFullYear(currentDate.getFullYear() + amount);
      }

      input.value = currentDate.toISOString().split('T')[0];
      
      // Update the display values
      updateDateDisplay(inputId);
      
      applyDateFilter();
    }

    // Zeit anpassen
    function adjustTime(inputId, amount, unit) {
      const input = document.getElementById(inputId);
      if (!input || !input.value) return;

      const [hours, minutes] = input.value.split(':').map(num => parseInt(num));
      const currentTime = new Date();
      currentTime.setHours(hours, minutes, 0);

      if (unit === 'hour') {
        currentTime.setHours(currentTime.getHours() + amount);
      } else if (unit === 'minute') {
        currentTime.setMinutes(currentTime.getMinutes() + amount);
      }

      const adjustedHours = currentTime.getHours().toString().padStart(2, '0');
      const adjustedMinutes = currentTime.getMinutes().toString().padStart(2, '0');
      input.value = `${adjustedHours}:${adjustedMinutes}`;
      
      // Update the display values
      updateTimeDisplay(inputId);
      
      applyDateFilter();
    }

    // Format a date value into day, month, year parts
    function formatDateParts(dateValue) {
      const date = new Date(dateValue);
      return {
        day: date.getDate().toString().padStart(2, '0'),
        month: (date.getMonth() + 1).toString().padStart(2, '0'),
        year: date.getFullYear()
      };
    }

    // Format a time value into hour and minute parts
    function formatTimeParts(timeValue) {
      const [hours, minutes] = timeValue.split(':');
      return {
        hours: hours.padStart(2, '0'),
        minutes: minutes.padStart(2, '0')
      };
    }

    // Update the displayed date values
    function updateDateDisplay(inputId) {
      const input = document.getElementById(inputId);
      if (!input || !input.value) return;
      
      const parts = formatDateParts(input.value);
      const container = input.closest('.date-time-flex-container');
      
      if (!container) return;
      
      // Find the date input container
      const dateContainer = Array.from(container.querySelectorAll('.input-with-controls')).find(
        cont => cont.contains(input)
      );
      
      if (!dateContainer) return;
      
      // Get all value-display elements in proper order
      const displayElements = dateContainer.querySelectorAll('.value-display');
      
      if (displayElements.length >= 3) {
        // Update in correct order - first is day, second is month, third is year
        displayElements[0].textContent = parts.day;
        displayElements[1].textContent = parts.month;
        displayElements[2].textContent = parts.year;
      }
    }

    // Update the displayed time values
    function updateTimeDisplay(inputId) {
      const input = document.getElementById(inputId);
      if (!input || !input.value) return;
      
      const parts = formatTimeParts(input.value);
      const dateTimeFlexContainer = input.closest('.date-time-flex-container');
      
      // First find the time input container within the flex container
      const timeInputContainer = Array.from(dateTimeFlexContainer.querySelectorAll('.input-with-controls')).find(
        container => container.contains(input)
      );
      
      if (!timeInputContainer) return;
      
      // Now find the hour and minute displays within this specific time input container
      const hoursDisplay = timeInputContainer.querySelector('.input-section:nth-child(1) .value-display');
      const minutesDisplay = timeInputContainer.querySelector('.input-section:nth-child(3) .value-display');
      
      if (hoursDisplay) hoursDisplay.textContent = parts.hours;
      if (minutesDisplay) minutesDisplay.textContent = parts.minutes;
    }

    // Initialize date and time displays
    function initDateTimeDisplays() {
      // Initialize start date and time displays
      updateDateDisplay('startDate');
      updateTimeDisplay('startTime');
      
      // Initialize end date and time displays
      updateDateDisplay('endDate');
      updateTimeDisplay('endTime');
      
      // Set up event listeners for direct input changes
      document.getElementById('startDate').addEventListener('change', function() {
        updateDateDisplay('startDate');
      });
      
      document.getElementById('startTime').addEventListener('change', function() {
        updateTimeDisplay('startTime');
      });
      
      document.getElementById('endDate').addEventListener('change', function() {
        updateDateDisplay('endDate');
      });
      
      document.getElementById('endTime').addEventListener('change', function() {
        updateTimeDisplay('endTime');
      });
      
      // Add tap handlers for the date/time display elements to show native pickers on mobile
      document.querySelectorAll('.input-section .value-display').forEach(element => {
        element.addEventListener('click', function() {
          // Find the associated hidden input
          const section = this.closest('.input-section');
          const container = section.closest('.input-with-controls');
          const hiddenInput = container.querySelector('.hidden-input');
          
          if (hiddenInput) {
            // Focus and open the native picker
            hiddenInput.click();
            hiddenInput.focus();
          }
        });
      });
    }    // Update the timeframe indicator display
    function updateTimeframeDisplay() {
      if (!startDateFilter || !endDateFilter) return;
      
      // Use the same filter objects that are used elsewhere for consistency
      const startDateTime = startDateFilter;
      const endDateTime = endDateFilter;
      
      // Calculate time difference in milliseconds
      const timeDiff = endDateTime - startDateTime;
      
      // Convert to days, hours, minutes
      const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
      const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
      
      // Log for debugging
      console.log("Timeframe display calculation:", {
        startDateTime, endDateTime, timeDiff, days, hours, minutes
      });
      
      // Format the duration text
      let durationText = '';
      if (days > 0) {
        durationText += `${days} ${days === 1 ? 'Tag' : 'Tage'}`;
        if (hours > 0 || minutes > 0) durationText += ', ';
      }
      if (hours > 0) {
        durationText += `${hours} ${hours === 1 ? 'Stunde' : 'Stunden'}`;
        if (minutes > 0) durationText += ', ';
      }
      if (minutes > 0 || (days === 0 && hours === 0)) {
        durationText += `${minutes} ${minutes === 1 ? 'Minute' : 'Minuten'}`;
      }
      
      // Update the timeframe display
      document.getElementById('timeframeDisplay').textContent = durationText;
    }// Timeframe navigation functions with a simpler approach avoiding time parsing issues
    function movePreviousPeriod() {
      // Get the current date and time values
      const startDate = document.getElementById('startDate').value;
      const startTime = document.getElementById('startTime').value || "00:00";
      const endDate = document.getElementById('endDate').value;
      const endTime = document.getElementById('endTime').value || "00:00";
      
      if (!startDate || !endDate) return;
      
      // First calculate the exact duration in days
      const startParts = startDate.split('-').map(Number);
      const endParts = endDate.split('-').map(Number);
      const startTimeParts = startTime.split(':').map(Number);
      const endTimeParts = endTime.split(':').map(Number);
      
      // Manually create Date objects to avoid timezone issues
      const start = new Date(startParts[0], startParts[1]-1, startParts[2], startTimeParts[0], startTimeParts[1], 0);
      const end = new Date(endParts[0], endParts[1]-1, endParts[2], endTimeParts[0], endTimeParts[1], 0);
      
      console.log("Previous period - manual dates:", { start, end });
      
      // Calculate duration in milliseconds
      const durationMs = end - start;
      console.log("Duration in ms:", durationMs);
      
      // Calculate new dates
      const newStart = new Date(start.getTime() - durationMs);
      const newEnd = new Date(end.getTime() - durationMs);
      
      console.log("Previous period - new dates:", { newStart, newEnd });
      
      // Format date strings consistently
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      const formatTime = (date) => {
        return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
      };
      
      // Update input fields
      document.getElementById('startDate').value = formatDate(newStart);
      document.getElementById('startTime').value = formatTime(newStart);
      document.getElementById('endDate').value = formatDate(newEnd);
      document.getElementById('endTime').value = formatTime(newEnd);
      
      // Update displays and apply filter
      updateDateDisplay('startDate');
      updateTimeDisplay('startTime');
      updateDateDisplay('endDate');
      updateTimeDisplay('endTime');
      
      // Direct filter application (don't use applyDateFilter to avoid parsing issues)
      startDateFilter = newStart;
      endDateFilter = new Date(newEnd);
      endDateFilter.setSeconds(59, 999); // End of minute
      
      // Update the slider if it exists
      if (window.dateSlider) {
        window.dateSlider.set([newStart.getTime(), newEnd.getTime()]);
      }
      
      applyFilters();
      processAllData();
      
      // Update the timeframe display
      updateTimeframeDisplay();
    }
    
    function moveNextPeriod() {
      // Get the current date and time values
      const startDate = document.getElementById('startDate').value;
      const startTime = document.getElementById('startTime').value || "00:00";
      const endDate = document.getElementById('endDate').value;
      const endTime = document.getElementById('endTime').value || "00:00";
      
      if (!startDate || !endDate) return;
      
      // First calculate the exact duration in days
      const startParts = startDate.split('-').map(Number);
      const endParts = endDate.split('-').map(Number);
      const startTimeParts = startTime.split(':').map(Number);
      const endTimeParts = endTime.split(':').map(Number);
      
      // Manually create Date objects to avoid timezone issues
      const start = new Date(startParts[0], startParts[1]-1, startParts[2], startTimeParts[0], startTimeParts[1], 0);
      const end = new Date(endParts[0], endParts[1]-1, endParts[2], endTimeParts[0], endTimeParts[1], 0);
      
      console.log("Next period - manual dates:", { start, end });
      
      // Calculate duration in milliseconds
      const durationMs = end - start;
      console.log("Duration in ms:", durationMs);
      
      // Calculate new dates
      const newStart = new Date(start.getTime() + durationMs);
      const newEnd = new Date(end.getTime() + durationMs);
      
      console.log("Next period - new dates:", { newStart, newEnd });
      
      // Format date strings consistently
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      const formatTime = (date) => {
        return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
      };
      
      // Update input fields
      document.getElementById('startDate').value = formatDate(newStart);
      document.getElementById('startTime').value = formatTime(newStart);
      document.getElementById('endDate').value = formatDate(newEnd);
      document.getElementById('endTime').value = formatTime(newEnd);
      
      // Update displays and apply filter
      updateDateDisplay('startDate');
      updateTimeDisplay('startTime');
      updateDateDisplay('endDate');
      updateTimeDisplay('endTime');
      
      // Direct filter application (don't use applyDateFilter to avoid parsing issues)
      startDateFilter = newStart;
      endDateFilter = new Date(newEnd);
      endDateFilter.setSeconds(59, 999); // End of minute
      
      // Update the slider if it exists
      if (window.dateSlider) {
        window.dateSlider.set([newStart.getTime(), newEnd.getTime()]);
      }
      
      applyFilters();
      processAllData();
      
      // Update the timeframe display
      updateTimeframeDisplay();
    }

    // Improved function to dynamically determine the appropriate aggregation interval
    function getAggregationInterval(startDate, endDate) {
      // Get the timeframe duration in milliseconds
      const duration = endDate - startDate;
      const hours = duration / (1000 * 60 * 60);
      
      // Define thresholds for different aggregation intervals
      if (hours <= 24) {
        // For timeframes <= 24 hours: aggregate by hour
        return {
          interval: 'hour',
          format: (date) => `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')} ${date.getHours()}:00`,
          roundFn: (timestamp) => new Date(
            timestamp.getFullYear(),
            timestamp.getMonth(),
            timestamp.getDate(),
            timestamp.getHours()
          )
        };
      } else if (hours <= 7 * 24) { 
        // For timeframes <= 1 week: aggregate by day
        return {
          interval: 'day',
          format: (date) => `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')}`,
          roundFn: (timestamp) => new Date(
            timestamp.getFullYear(),
            timestamp.getMonth(),
            timestamp.getDate()
          )
        };
      } else if (hours <= 31 * 24) {
        // For timeframes <= 1 month: aggregate by day
        return {
          interval: 'day',
          format: (date) => `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')}`,
          roundFn: (timestamp) => new Date(
            timestamp.getFullYear(),
            timestamp.getMonth(),
            timestamp.getDate()
          )
        };
      } else {
        // For timeframes > 1 month: aggregate by week
        return {
          interval: 'week',
          format: (date) => {
            const weekNumber = Math.ceil((date.getDate() + new Date(date.getFullYear(), date.getMonth(), 1).getDay()) / 7);
            return `KW${weekNumber} ${date.toLocaleString('default', { month: 'short' })}`;
          },
          roundFn: (timestamp) => {
            const date = new Date(timestamp);
            const day = date.getDay();
            const diff = date.getDate() - day + (day === 0 ? -6 : 1); // Adjust to Monday
            return new Date(date.setDate(diff));
          }
        };
      }
    }

    // Initialize and setup the date range slider
    function initDateRangeSlider() {
      const sliderElement = document.getElementById('dateRangeSlider');
      if (!sliderElement) return;
      
      // Get data range from all data
      let minDate, maxDate;
        // Find earliest and latest dates across all datasets
      function findDateRange() {
        let allDates = [];
        
        // Collect all timestamps from all datasets
        [allStatusData, allErrorData, allPatternData, allInputData].forEach(dataset => {
          if (!dataset || !dataset.length) return;
          
          dataset.forEach(entry => {
            if (entry && entry.Zeitpunkt) {
              try {
                // Parse date correctly - use standard format from your data
                const dateStr = entry.Zeitpunkt;
                const date = new Date(dateStr);
                
                // Validate that the resulting date is valid before adding it
                if (!isNaN(date.getTime())) {
                  allDates.push(date);
                } else {
                  console.warn("Invalid date format:", dateStr);
                }
              } catch (e) {
                console.warn("Invalid date:", entry.Zeitpunkt, e);
              }
            }
          });
        });
        
        console.log("All dates found:", allDates.length);
        
        // Sort dates and get min/max
        if (allDates.length) {
          allDates.sort((a, b) => a - b);
          
          // Log the actual min/max found in data for debugging
          console.log("Min date from data:", allDates[0]);
          console.log("Max date from data:", allDates[allDates.length - 1]);
          
          return {
            min: allDates[0],
            max: allDates[allDates.length - 1]
          };
        }
        
        // Default if no dates found
        const now = new Date();
        const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        console.log("No valid dates found - using defaults:", oneWeekAgo, "to", now);
        
        return {
          min: oneWeekAgo, // 1 week ago
          max: now
        };
      }
        const dateRange = findDateRange();
      minDate = dateRange.min;
      maxDate = dateRange.max;
      
      // Ensure max date doesn't exceed current time
      const currentTime = new Date();
      if (maxDate > currentTime) {
        console.log("Max date exceeds current time, limiting to now:", maxDate, "→", currentTime);
        maxDate = currentTime;
      }
      
      // Add 1 hour buffer to max date (but don't exceed current time + 1 hour)
      const maxAllowedTime = new Date(Math.min(
        maxDate.getTime() + 60 * 60 * 1000,
        currentTime.getTime() + 60 * 60 * 1000
      ));
      maxDate = maxAllowedTime;
      
      // Current filter values, defaulting to full range if not set
      const startTime = startDateFilter || minDate;
      const endTime = endDateFilter || maxDate;
      
      // Create or update the slider
      if (window.dateSlider) {
        window.dateSlider.destroy();
      }
      
      // Format timestamps for tooltips and display
      function formatSliderDate(timestamp) {
        const date = new Date(timestamp);
        return moment(date).format('DD.MM.YYYY HH:mm');
      }      // Create the slider
      window.dateSlider = noUiSlider.create(sliderElement, {
        start: [startTime.getTime(), endTime.getTime()],
        connect: true,
        range: {
          'min': minDate.getTime(),
          'max': maxDate.getTime()
        },
        step: 60 * 1000, // 1 minute steps
        format: {
          to: value => Math.round(value),
          from: value => Math.round(value)
        },
        // Disable the default tooltips as we'll create our own duration tooltip
        tooltips: false,
        // Enable dragging the middle bar to move the entire range
        behaviour: 'drag',
        // Enable dragging individual handles too
        dragAll: true
      });      // Add custom duration tooltip to the slider container
      // Note: we'll add it to the container instead of the connecting bar which might not be accessible
      const durationTooltip = document.createElement('div');
      durationTooltip.id = 'sliderDurationTooltip';
      durationTooltip.className = 'slider-duration-tooltip';
      durationTooltip.style.position = 'absolute';
      durationTooltip.style.top = '-30px';
      durationTooltip.style.left = '50%';
      durationTooltip.style.transform = 'translateX(-50%)';
      durationTooltip.style.backgroundColor = 'var(--accent-color)';
      durationTooltip.style.color = 'white';
      durationTooltip.style.padding = '4px 8px';
      durationTooltip.style.borderRadius = '4px';
      durationTooltip.style.fontSize = '12px';
      durationTooltip.style.whiteSpace = 'nowrap';
      durationTooltip.style.zIndex = '5';
      durationTooltip.style.display = 'block';
      durationTooltip.style.cursor = 'grab'; // Show cursor as grab to indicate it's draggable
      sliderElement.style.position = 'relative'; // Ensure tooltip is positioned relative to slider
      sliderElement.appendChild(durationTooltip);// Use the same global formatting function that will be used in both places
      
      // Set initial tooltip text
      durationTooltip.textContent = formatDuration(startTime.getTime(), endTime.getTime());
      
      // Make duration tooltip draggable to move both handles together
      makeTooltipDraggable(durationTooltip, sliderElement);
      
      // Update timestamp displays
      document.getElementById('sliderStartTimestamp').textContent = 
        'Start: ' + formatSliderDate(startTime);
      document.getElementById('sliderEndTimestamp').textContent = 
        'Ende: ' + formatSliderDate(endTime);
      
      // Generate markers for significant time points
      createTimeMarkers(minDate, maxDate);      // Function to make the duration tooltip draggable to move both handles
      function makeTooltipDraggable(tooltip, sliderElement) {
        // Find the noUi-connect element (the draggable bar between handles)
        const connectBar = sliderElement.querySelector('.noUi-connect');
        if (!connectBar) return;
        
        // Set the initial grab cursor to indicate draggability
        tooltip.style.cursor = 'grab';
        
        // Helper to get mouse position relative to the slider
        function getRelativeMousePosition(e, slider) {
          const rect = slider.getBoundingClientRect();
          const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
          return {
            x: clientX - rect.left,
            y: 0
          };
        }        // Mobile touch support - handle touch events first
        tooltip.addEventListener('touchstart', function(e) {
          if (!e.touches || !e.touches[0]) return;
          e.preventDefault();
          
          // Change cursor and add shadow effect for dragging appearance
          tooltip.style.cursor = 'grabbing';
          tooltip.style.boxShadow = '0 2px 8px rgba(0,0,0,0.4)';
          
          // Get the touch coordinates
          const touch = e.touches[0];
          
          // Instead of creating synthetic events, directly trigger noUiSlider's API
          // First, get current slider values
          const values = window.dateSlider.get().map(Number);
          const startTime = values[0];
          const endTime = values[1];
          const duration = endTime - startTime;
          
          // Save starting touch position for calculating drag distance
          const startTouchX = touch.clientX;
          const sliderRect = sliderElement.getBoundingClientRect();
          const sliderRange = window.dateSlider.options.range;
          const timeRange = sliderRange.max - sliderRange.min;
          
          // Setup touch move handler
          function onTouchMove(moveEvent) {
            if (!moveEvent.touches[0]) return;
            moveEvent.preventDefault();
            
            // Calculate horizontal distance moved
            const currentX = moveEvent.touches[0].clientX;
            const deltaX = currentX - startTouchX;
            
            // Convert pixel movement to time value movement
            const pixelRatio = sliderRect.width / timeRange;
            const timeShift = deltaX / pixelRatio;
            
            // Calculate new start and end times
            let newStart = startTime + timeShift;
            let newEnd = endTime + timeShift;
            
            // Enforce slider boundaries
            if (newStart < sliderRange.min) {
              const diff = sliderRange.min - newStart;
              newStart = sliderRange.min;
              newEnd = newEnd + diff;
            } else if (newEnd > sliderRange.max) {
              const diff = newEnd - sliderRange.max;
              newEnd = sliderRange.max;
              newStart = newStart - diff;
            }
            
            // Set new values directly through noUiSlider API
            window.dateSlider.set([newStart, newEnd]);
          }
          
          // Setup touch end handler
          function onTouchEnd() {
            tooltip.style.cursor = 'grab';
            tooltip.style.boxShadow = '';
            document.removeEventListener('touchmove', onTouchMove);
            document.removeEventListener('touchend', onTouchEnd);
            document.removeEventListener('touchcancel', onTouchEnd);
            
            // Apply changes via the filter system
            const finalValues = window.dateSlider.get().map(Number);
            updateDateFiltersFromSlider(finalValues[0], finalValues[1]);
            applyFilters();
            processAllData();
          }
          
          // Add event listeners for touch movement and end
          document.addEventListener('touchmove', onTouchMove, { passive: false });
          document.addEventListener('touchend', onTouchEnd);
          document.addEventListener('touchcancel', onTouchEnd);
        });
        
        // Mouse support for desktop - as fallback
        tooltip.addEventListener('mousedown', function(e) {
          // Prevent the default to avoid text selection
          e.preventDefault();
          
          // Change cursor to grabbing during drag
          tooltip.style.cursor = 'grabbing';
          tooltip.style.boxShadow = '0 2px 8px rgba(0,0,0,0.4)'; // Visual feedback
          
          // Get the slider dimensions
          const sliderRect = sliderElement.getBoundingClientRect();
          
          // Calculate the exact position where the connect bar should be clicked
          const connectRect = connectBar.getBoundingClientRect();
          const connectCenter = (connectRect.left + connectRect.right) / 2 - sliderRect.left;
          
          // Create and dispatch a mousedown event on the connect bar
          const mouseEvent = new MouseEvent('mousedown', {
            bubbles: true,
            cancelable: true,
            view: window,
            clientX: sliderRect.left + connectCenter,
            clientY: e.clientY,
            screenX: sliderRect.left + connectCenter,
            screenY: e.screenY,
            button: 0,
            buttons: 1 // Left button pressed
          });
          
          // Need to both prevent this event and dispatch a new one
          e.stopPropagation();
          
          // This is the key part - dispatch the event on the connect bar
          connectBar.dispatchEvent(mouseEvent);
          
          // Set up mouseup listener to restore tooltip appearance
          const onMouseUp = function() {
            tooltip.style.cursor = 'grab';
            tooltip.style.boxShadow = '';
            document.removeEventListener('mouseup', onMouseUp);
          };
          document.addEventListener('mouseup', onMouseUp);
        });
      }      // Handle slider changes
      window.dateSlider.on('update', function(values, handle) {
        const timestamps = values.map(Number);
        
        // Update timestamp displays
        document.getElementById('sliderStartTimestamp').textContent = 
          'Start: ' + formatSliderDate(timestamps[0]);
        document.getElementById('sliderEndTimestamp').textContent = 
          'Ende: ' + formatSliderDate(timestamps[1]);
          
        // Calculate duration text once for both displays
        const durationText = formatDuration(timestamps[0], timestamps[1]);
        
        // Update duration tooltip 
        const durationTooltip = document.getElementById('sliderDurationTooltip');
        if (durationTooltip) {
          durationTooltip.textContent = durationText;
          
          // Update position to center over the selected range
          const sliderRect = sliderElement.getBoundingClientRect();
          const lowerHandle = sliderElement.querySelector('.noUi-handle-lower');
          const upperHandle = sliderElement.querySelector('.noUi-handle-upper');
          
          if (lowerHandle && upperHandle) {
            const lowerPos = lowerHandle.getBoundingClientRect().left - sliderRect.left;
            const upperPos = upperHandle.getBoundingClientRect().left - sliderRect.left;
            const center = lowerPos + (upperPos - lowerPos) / 2;
            
            durationTooltip.style.left = center + 'px';
          }
        }
        
        // Update timeframeDisplay with the same text
        const timeframeDisplay = document.getElementById('timeframeDisplay');
        if (timeframeDisplay) {
          timeframeDisplay.textContent = durationText;
        }
      });// Apply filter when slider changes end
      window.dateSlider.on('change', function(values) {
        console.log("Slider change event triggered with values:", values);
        
        const timestamps = values.map(Number);
        
        // Create Date objects
        const newStartDate = new Date(timestamps[0]);
        const newEndDate = new Date(timestamps[1]);
        
        console.log("New date range:", newStartDate, newEndDate);
        
        // Update input fields
        const formatDate = (date) => {
          const year = date.getFullYear();
          const month = (date.getMonth() + 1).toString().padStart(2, '0');
          const day = date.getDate().toString().padStart(2, '0');
          return `${year}-${month}-${day}`;
        };
        
        const formatTime = (date) => {
          return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
        };
        
        // Set the date and time input fields
        document.getElementById('startDate').value = formatDate(newStartDate);
        document.getElementById('startTime').value = formatTime(newStartDate);
        document.getElementById('endDate').value = formatDate(newEndDate);
        document.getElementById('endTime').value = formatTime(newEndDate);
        
        // Update displays
        updateDateDisplay('startDate');
        updateTimeDisplay('startTime');
        updateDateDisplay('endDate');
        updateTimeDisplay('endTime');
        
        // Update filter variables directly
        startDateFilter = newStartDate;
        endDateFilter = newEndDate;
        endDateFilter.setSeconds(59, 999); // Set to end of minute
        
        // Apply filters and update charts
        applyFilters();
        processAllData();
        updateTimeframeDisplay();
        
        // Update slider timestamps
        document.getElementById('sliderStartTimestamp').textContent = 
          'Start: ' + formatSliderDate(newStartDate);
        document.getElementById('sliderEndTimestamp').textContent = 
          'Ende: ' + formatSliderDate(newEndDate);
      });      // Add event listeners to the shift range buttons - use the same functions as the timeframe buttons
      document.getElementById('shiftRangeLeft').addEventListener('click', function() {
        movePreviousPeriod();
      });
      
      document.getElementById('shiftRangeRight').addEventListener('click', function() {
        moveNextPeriod();
      });
    }
    
    // Create time markers for the slider
    function createTimeMarkers(minDate, maxDate) {
      const markersContainer = document.getElementById('sliderMarkers');
      if (!markersContainer) return;
      
      markersContainer.innerHTML = '';
      
      // Determine appropriate interval based on timeframe length
      const timeRange = maxDate - minDate;
      const dayRange = timeRange / (24 * 60 * 60 * 1000);
      
      let interval;
      let format;
      
      if (dayRange <= 1) { // Less than a day
        interval = 3 * 60 * 60 * 1000; // Every 3 hours
        format = 'HH:mm';
      } else if (dayRange <= 7) { // Less than a week
        interval = 24 * 60 * 60 * 1000; // Daily
        format = 'DD.MM';
      } else if (dayRange <= 31) { // Less than a month
        interval = 7 * 24 * 60 * 60 * 1000; // Weekly
        format = 'DD.MM';
      } else { // More than a month
        interval = 30 * 24 * 60 * 60 * 1000; // Monthly
        format = 'MM/YY';
      }
      
      // Generate markers
      const totalWidth = markersContainer.offsetWidth;
      let currentTime = new Date(minDate);
      
      while (currentTime < maxDate) {
        const markerTime = new Date(currentTime);
        
        // Calculate position as percentage
        const percent = (markerTime - minDate) / (maxDate - minDate) * 100;
        
        // Create marker element
        const marker = document.createElement('div');
        marker.className = 'slider-marker';
        marker.style.left = `${percent}%`;
        
        // Create label
        const label = document.createElement('div');
        label.className = 'slider-marker-label';
        label.style.left = `${percent}%`;
        label.textContent = moment(markerTime).format(format);
        
        markersContainer.appendChild(marker);
        markersContainer.appendChild(label);
        
        // Move to next interval
        currentTime = new Date(currentTime.getTime() + interval);
      }
    }    // Function to shift the entire date range by a percentage of its current span
    function shiftDateRange(direction) {
      // Check if slider exists
      if (!window.dateSlider) return;
      
      // Get current range values
      const currentValues = window.dateSlider.get().map(Number);
      const startTime = currentValues[0];
      const endTime = currentValues[1];
      
      // Calculate range duration
      const rangeDuration = endTime - startTime;
      
      // Shift by 25% of current range
      const shiftAmount = rangeDuration * 0.25 * direction;
      
      // Calculate new values
      const newStart = startTime + shiftAmount;
      const newEnd = endTime + shiftAmount;
      
      // Get slider min/max values from noUiSlider
      const sliderRange = window.dateSlider.options.range;
      const minBound = sliderRange.min;
      const maxBound = sliderRange.max;
      
      // Check if new range is within bounds
      let updatedStart, updatedEnd;
      
      if (newStart < minBound) {
        // If shifting would exceed lower bound, snap to minimum
        updatedStart = minBound;
        updatedEnd = minBound + rangeDuration;
        window.dateSlider.set([updatedStart, updatedEnd]);
      } else if (newEnd > maxBound) {
        // If shifting would exceed upper bound, snap to maximum
        updatedStart = maxBound - rangeDuration;
        updatedEnd = maxBound;
        window.dateSlider.set([updatedStart, updatedEnd]);
      } else {
        // Otherwise shift normally
        updatedStart = newStart;
        updatedEnd = newEnd;
        window.dateSlider.set([updatedStart, updatedEnd]);
      }
      
      // Apply the filter with the new date range
      updateDateFiltersFromSlider(updatedStart, updatedEnd);
      
      // Apply filters and update the charts
      applyFilters();
      processAllData();
      updateTimeframeDisplay();
    }
    
    // Helper function to update date filter inputs based on slider values
    function updateDateFiltersFromSlider(startTimestamp, endTimestamp) {
      // Create Date objects from timestamps
      const startDate = new Date(startTimestamp);
      const endDate = new Date(endTimestamp);
      
      // Format for input fields
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      const formatTime = (date) => {
        return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
      };
      
      // Update input fields
      document.getElementById('startDate').value = formatDate(startDate);
      document.getElementById('startTime').value = formatTime(startDate);
      document.getElementById('endDate').value = formatDate(endDate);
      document.getElementById('endTime').value = formatTime(endDate);
      
      // Update displays
      updateDateDisplay('startDate');
      updateTimeDisplay('startTime');
      updateDateDisplay('endDate');
      updateTimeDisplay('endTime');
      
      // Update filter variables directly
      startDateFilter = new Date(startDate);
      endDateFilter = new Date(endDate);
      endDateFilter.setSeconds(59, 999); // Set to end of minute
    }// Global function to format duration consistently across the dashboard
    function formatDuration(startTime, endTime) {
      // Calculate time difference in milliseconds
      const timeDiff = endTime - startTime;
      
      // Convert to days, hours, minutes
      const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
      const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
      
      // Format the duration text
      let durationText = '';
      if (days > 0) {
        durationText += `${days} ${days === 1 ? 'Tag' : 'Tage'}`;
        if (hours > 0 || minutes > 0) durationText += ', ';
      }
      if (hours > 0) {
        durationText += `${hours} ${hours === 1 ? 'Stunde' : 'Stunden'}`;
        if (minutes > 0) durationText += ', ';
      }
      if (minutes > 0 || (days === 0 && hours === 0)) {
        durationText += `${minutes} ${minutes === 1 ? 'Minute' : 'Minuten'}`;
      }
      
      return durationText;
    }
      // Toggle filter visibility
    function toggleFilter() {
      const filterContent = document.getElementById('filterContent');
      const filterHeader = document.querySelector('.filter-header');
      const toggleIcon = document.getElementById('toggleFilterIcon');
      
      // Toggle collapsed state
      if (filterContent.classList.contains('collapsed')) {
        // Expand
        filterContent.classList.remove('collapsed');
        filterHeader.classList.remove('collapsed');
        toggleIcon.textContent = 'expand_less';
        
        // Store preference in localStorage
        localStorage.setItem('filterCollapsed', 'false');
      } else {
        // Collapse
        filterContent.classList.add('collapsed');
        filterHeader.classList.add('collapsed');
        toggleIcon.textContent = 'expand_more';
        
        // Store preference in localStorage
        localStorage.setItem('filterCollapsed', 'true');
      }
    }    // Toggle card content visibility - Material 3 approach
    function toggleCard(cardId) {
      const card = document.getElementById(cardId);
      const cardContent = card.querySelector('.mdl-card__supporting-text');
      const toggleIcon = card.querySelector('.toggle-card-btn i');
      
      if (!cardContent || !toggleIcon) return;
      
      // Toggle collapsed state
      if (cardContent.classList.contains('collapsed')) {
        // EXPAND: First make visible before animating height
        
        // Step 1: Change icon immediately for visual feedback
        toggleIcon.textContent = 'expand_less';
        
        // Step 2: Remove collapsed class to trigger CSS transitions
        cardContent.classList.remove('collapsed');
        card.classList.remove('collapsed-card');
        
        // Step 3: Let CSS handle the transition and avoid inline styles
        // This will use the max-height defined in CSS instead
        
        // Step 4: Make canvases visible again
        cardContent.querySelectorAll('canvas').forEach(canvas => {
          canvas.style.visibility = 'visible';
        });
        
        // Step 5: Trigger chart redraw after animation completes
        setTimeout(() => {
          window.dispatchEvent(new Event('resize'));
        }, 350); // Slightly longer than transition
        
        // Store preference in localStorage
        localStorage.setItem(`card_${cardId}_collapsed`, 'false');
      } else {
        // COLLAPSE: First set height to 0, then hide
        
        // Step 1: Change icon immediately for visual feedback
        toggleIcon.textContent = 'expand_more';
        
        // Step 2: Hide canvas elements immediately to save rendering resources
        cardContent.querySelectorAll('canvas').forEach(canvas => {
          canvas.style.visibility = 'hidden';
        });
        
        // Step 3: Add collapsed classes to trigger CSS transitions
        cardContent.classList.add('collapsed');
        card.classList.add('collapsed-card');
        
        // Store preference in localStorage
        localStorage.setItem(`card_${cardId}_collapsed`, 'true');
      }
    }
  </script>
</body>
</html>