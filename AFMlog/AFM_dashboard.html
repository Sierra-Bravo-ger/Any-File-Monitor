<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <title>AnyFileMonitor Dashboard</title>
  <!-- Material Design Lite -->
  <link rel="stylesheet" href="libs/fonts/material-icons.css">
  <link rel="stylesheet" href="libs/css/material.indigo-pink.min.css">
  <script defer src="libs/js/material.min.js"></script>
  <!-- PapaParse für CSV-Parsing -->
  <script src="libs/js/papaparse.min.js"></script>
  <!-- Chart.js für Diagramme -->
  <script src="libs/js/chart.js"></script>
  <script src="libs/js/chartjs-chart-matrix.min.js"></script>
  <script src="libs/js/chartjs-plugin-datalabels.js"></script>
  <!-- Moment.js für Datumsfunktionen -->
  <script src="libs/js/moment.min.js"></script>
  <script src="libs/js/moment-de.js"></script>
  <style>
    :root {
      /* Light Theme Variablen */
      --bg-color: #f5f5f5;
      --card-bg-color: #ffffff;
      --text-color: #212121;
      --secondary-text-color: #757575;
      --header-bg-color: #3f51b5;
      --header-text-color: #ffffff;
      --card-title-bg-color: #3f51b5;
      --card-title-text-color: #ffffff;
      --card-shadow: 0 2px 5px 0 rgba(0,0,0,0.16), 0 2px 10px 0 rgba(0,0,0,0.12);
      --accent-color: #3f51b5;
      --hover-color: rgba(0, 0, 0, 0.05);
      --border-color: #ddd;
      --chart-grid-color: rgba(0, 0, 0, 0.1);
      --success-color: #4caf50;
      --warning-color: #ff9800;
      --error-color: #f44336;
      --error-card-bg: #ffebee;
      --error-card-border: #f44336;
      --warning-card-bg: #fff8e1;
      --warning-card-border: #ffc107;
      --success-card-bg: #e8f5e9;
      --success-card-border: #4caf50;
      --tooltip-bg: #555;
      --tooltip-text: #fff;
    }

    [data-theme="dark"] {
      /* Dark Theme Variablen */
      --bg-color: #121212;
      --card-bg-color: #1e1e1e;
      --text-color: #e0e0e0;
      --secondary-text-color: #aaaaaa;
      --header-bg-color: #272727;
      --header-text-color: #e0e0e0;
      --card-title-bg-color: #272727;
      --card-title-text-color: #e0e0e0;
      --card-shadow: 0 2px 5px 0 rgba(0,0,0,0.5), 0 2px 10px 0 rgba(0,0,0,0.5);
      --accent-color: #5c6bc0;
      --hover-color: rgba(255, 255, 255, 0.05);
      --border-color: #444;
      --chart-grid-color: rgba(255, 255, 255, 0.1);
      --success-color: #81c784;
      --warning-color: #ffb74d;
      --error-color: #e57373;
      --error-card-bg: rgba(244, 67, 54, 0.15);
      --error-card-border: #e57373;
      --warning-card-bg: rgba(255, 193, 7, 0.15);
      --warning-card-border: #ffb74d;
      --success-card-bg: rgba(76, 175, 80, 0.15);
      --success-card-border: #81c784;
      --tooltip-bg: #333;
      --tooltip-text: #e0e0e0;
    }
    
    [data-theme="dark"] #healthScore {
      color: var(--text-color); /* Verwende die Textfarbe aus dem Dark Mode Farbschema */
    }

    [data-theme="dark"] #topErrorsList div {
      color: #ffffff; /* Weiß-Ton nur im Dark Mode */
    }
    
    body { 
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }
    .page-content {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .mdl-card {
      width: 100%;
      margin-bottom: 24px;
      overflow: visible;
      background-color: var(--card-bg-color);
      box-shadow: var(--card-shadow);
    }
    .mdl-card__title {
      color: var(--card-title-text-color);
      height: 64px;
      background-color: var(--card-title-bg-color);
    }
    .mdl-card__title-text {
      font-size: 20px;
      color: var(--card-title-text-color);
    }
    .mdl-data-table {
      width: 100%;
      background-color: var(--card-bg-color);
      color: var(--text-color);
      border-color: var(--border-color);
    }
    .mdl-data-table th {
      color: var(--text-color);
      border-bottom-color: var(--border-color);
    }
    .mdl-data-table td {
      color: var(--text-color);
      border-bottom-color: var(--border-color);
    }
    .summary-card {
      padding: 16px;
      margin-bottom: 24px;
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      background-color: var(--card-bg-color);
    }
    .summary-item {
      text-align: center;
      padding: 16px;
      flex: 1;
      min-width: 150px;
    }
    .summary-value {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 8px;
      color: var(--accent-color);
    }
    .summary-label {
      font-size: 14px;
      color: var(--secondary-text-color);
    }
    .chart-container {
      height: 300px;
      margin-bottom: 24px;
      background-color: var(--card-bg-color);
    }
    .small-chart-container {
      height: 250px;
      margin-bottom: 16px;
      background-color: var(--card-bg-color);
    }
    .refresh-button {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 100;
    }
    .mdl-spinner {
      margin: 0 auto;
      display: block;
    }
    .loading {
      text-align: center;
      padding: 24px;
      color: var(--secondary-text-color);
    }
    .error-card {
      background-color: var(--error-card-bg);
      border-left: 4px solid var(--error-card-border);
    }
    .warning-card {
      background-color: var(--warning-card-bg);
      border-left: 4px solid var(--warning-card-border);
    }
    .success-card {
      background-color: var(--success-card-bg);
      border-left: 4px solid var(--success-card-border);
    }
    #lastUpdate {
      text-align: right;
      color: var(--secondary-text-color);
      font-size: 12px;
      margin-bottom: 16px;
    }
    .mdl-layout__header {
      background-color: var(--header-bg-color);
    }
    .mdl-layout__header-row {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      padding: 0 16px;
    }
    
    .mdl-layout-title {
      text-align: center;
      font-size: 20px;
      font-weight: bold;
      white-space: nowrap;
      grid-column: 2;
      color: var(--header-text-color);
    }
    
    .header-left {
      display: flex;
      align-items: center;
      justify-content: flex-start;
    }
    
    .header-right {
      display: flex;
      justify-content: flex-end;
      grid-column: 3;
    }
    
    .mdl-navigation {
      display: flex;
      justify-content: flex-end;
      width: 100%;
    }
    .mdl-navigation__link {
      color: var(--header-text-color) !important;
    }
    .mdl-grid {
      padding: 0;
    }
    .mdl-cell {
      margin: 8px;
    }
    .kpi-card {
      padding: 16px;
      text-align: center;
      border-radius: 8px;
      border-top: 4px solid var(--accent-color);
      background-color: var(--card-bg-color);
      box-shadow: var(--card-shadow);
    }
    .kpi-value {
      font-size: 28px;
      font-weight: bold;
      margin: 8px 0;
      color: var(--accent-color);
    }
    .kpi-label {
      font-size: 14px;
      color: var(--secondary-text-color);
    }
    .status-indicator {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      margin-right: 8px;
    }
    .status-good {
      background-color: var(--success-color);
    }
    .status-warning {
      background-color: var(--warning-color);
    }
    .status-error {
      background-color: var(--error-color);
    }
    .filter-container {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
      flex-wrap: wrap;
      background-color: var(--card-bg-color);
    }
    .filter-item {
      margin: 8px;
    }
    .filter-label {
      font-size: 12px;
      margin-bottom: 4px;
      color: var(--secondary-text-color);
    }
    .tab-container {
      display: none;
    }
    .tab-container.active {
      display: block;
    }
    .pattern-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      color: var(--card-title-text-color);
      background-color: var(--accent-color);
      margin-right: 4px;
      margin-bottom: 4px;
    }
    .pattern-container {
      margin-top: 8px;
    }
    #searchInput {
      padding: 8px;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 16px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--card-bg-color);
      color: var(--text-color);
    }
    .info-icon {
      font-size: 16px;
      color: var(--secondary-text-color);
      cursor: help;
    }
    .tooltip {
      position: relative;
      display: inline-block;
    }
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: var(--tooltip-bg);
      color: var(--tooltip-text);
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    .two-columns {
      column-count: 2;
      column-gap: 20px;
    }
    .gauge-container {
      width: 200px;
      height: 100px;
      margin: 0 auto;
      position: relative;
    }
    .gauge-container canvas {
      width: 100%;
      height: 100%;
    }
    .gauge-label {
      position: absolute;
      bottom: 0;
      width: 100%;
      text-align: center;
      font-size: 14px;
      color: var(--secondary-text-color);
    }
    
    /* Styling für den Theme-Toggle-Button */
    .theme-toggle {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
      margin-right: 16px;
    }
    
    .theme-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .theme-toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }
    
    .theme-toggle-slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .theme-toggle-slider {
      background-color: var(--accent-color);
    }
    
    input:checked + .theme-toggle-slider:before {
      transform: translateX(30px);
    }
    
    .theme-toggle-icon {
      position: absolute;
      top: 6px;
      transition: .4s;
      font-size: 16px;
      color: white;
    }
    
    .theme-toggle-icon.sun {
      left: 8px;
      opacity: 0;
    }
    
    .theme-toggle-icon.moon {
      right: 8px;
      opacity: 1;
    }
    
    input:checked + .theme-toggle-slider .theme-toggle-icon.sun {
      opacity: 0;
    }
    
    input:checked + .theme-toggle-slider .theme-toggle-icon.moon {
      opacity: 1;
    }
    
    input:not(:checked) + .theme-toggle-slider .theme-toggle-icon.sun {
      opacity: 1;
    }
    
    input:not(:checked) + .theme-toggle-slider .theme-toggle-icon.moon {
      opacity: 0;
    }
    
    .mdl-layout__drawer {
      background-color: var(--card-bg-color);
      color: var(--text-color);
      border-color: var(--border-color);
    }
    
    .mdl-layout__drawer .mdl-navigation__link {
      color: var(--text-color) !important;
    }
    
    .mdl-layout__drawer .mdl-navigation__link:hover {
      background-color: var(--hover-color);
    }
    
    .mdl-button {
      color: var(--text-color);
    }
    
    .mdl-button--raised {
      background-color: var(--card-bg-color);
      color: var(--text-color);
    }

    .mdl-button--raised.mdl-button--colored {
      background-color: var(--accent-color);
      color: var(--card-title-text-color);
    }

    .mdl-layout-title {
      color: var(--header-text-color);
    }
    
    .mdl-layout__drawer .mdl-layout-title {
      color: var(--text-color);
      background-color: var(--card-bg-color);
    }

    .mdl-button--fab.mdl-button--colored {
      background: var(--accent-color);
      color: var(--card-title-text-color);
    }
    
    /* Dark-Mode Anpassungen für Input-Elemente */
    input[type="date"], input[type="time"] {
      background-color: var(--card-bg-color);
      color: var(--text-color);
      border: 1px solid var(--border-color);
    }
  </style>
</head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header">
    <header class="mdl-layout__header">
      <div class="mdl-layout__header-row">
        <div class="header-left" style="display: flex; align-items: center; margin-right: auto;">
          <!-- Theme-Toggle-Button mit Abstand zum Burger-Menü -->
          <label class="theme-toggle" style="margin-left: 48px;">
            <input type="checkbox" id="themeToggle" checked>
            <span class="theme-toggle-slider">
              <i class="material-icons theme-toggle-icon sun">wb_sunny</i>
              <i class="material-icons theme-toggle-icon moon">nights_stay</i>
            </span>
          </label>
        </div>
        <span class="mdl-layout-title">AnyFileMonitor Dashboard</span>
        <div class="header-right">
          <nav class="mdl-navigation">
            <a class="mdl-navigation__link" href="#overview" onclick="showTab('overview')">Übersicht</a>
            <a class="mdl-navigation__link" href="#status" onclick="showTab('status')">Status</a>
            <a class="mdl-navigation__link" href="#analysis" onclick="showTab('analysis')">Analyse</a>
            <a class="mdl-navigation__link" href="#errors" onclick="showTab('errors')">Fehler</a>
            <a class="mdl-navigation__link" href="#patterns" onclick="showTab('patterns')">Muster</a>
            <a class="mdl-navigation__link" href="#input" onclick="showTab('input')">Eingangsdaten</a>
          </nav>
        </div>
      </div>
    </header>
    <div class="mdl-layout__drawer">
      <span class="mdl-layout-title"> </span>
      <nav class="mdl-navigation">
        <a class="mdl-navigation__link" href="#overview" onclick="showTab('overview')">Übersicht</a>
        <a class="mdl-navigation__link" href="#status" onclick="showTab('status')">Status</a>
        <a class="mdl-navigation__link" href="#analysis" onclick="showTab('analysis')">Analyse</a>
        <a class="mdl-navigation__link" href="#errors" onclick="showTab('errors')">Fehler</a>
        <a class="mdl-navigation__link" href="#patterns" onclick="showTab('patterns')">Muster</a>
        <a class="mdl-navigation__link" href="#input" onclick="showTab('input')">Eingangsdaten</a>
      </nav>
    </div>
    <main class="mdl-layout__content">
      <div class="page-content">
        <div id="lastUpdate"></div>

        <!-- Filter für Zeitraum -->
        <div class="filter-container mdl-shadow--2dp" style="padding: 16px; background-color: var(--card-bg-color);">
          <div class="filter-group" style="display: flex; flex-direction: column; margin: 8px;">
            <label class="filter-label" style="font-size: 12px; margin-bottom: 4px; color: var(--secondary-text-color);">Startdatum und -zeit</label>
            <div style="display: flex; align-items: center;">
              <div style="display: flex; flex-direction: column; margin-right: 8px;">
                <!-- Aufwärts-Buttons für Datum -->
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustDate('startDate', 1, 'day')">
                    <i class="material-icons">arrow_upward</i>
                  </button>
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustDate('startDate', 1, 'month')">
                    <i class="material-icons">keyboard_arrow_up</i>
                  </button>
                </div>
                
                <!-- Datumsfeld -->
                <input class="mdl-textfield__input" type="date" id="startDate" style="margin-bottom: 4px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--card-bg-color); color: var(--text-color);">
                
                <!-- Abwärts-Buttons für Datum -->
                <div style="display: flex; justify-content: space-between;">
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustDate('startDate', -1, 'day')">
                    <i class="material-icons">arrow_downward</i>
                  </button>
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustDate('startDate', -1, 'month')">
                    <i class="material-icons">keyboard_arrow_down</i>
                  </button>
                </div>
              </div>
              
              <div style="display: flex; flex-direction: column;">
                <!-- Aufwärts-Buttons für Zeit -->
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustTime('startTime', 1, 'hour')">
                    <i class="material-icons">arrow_upward</i>
                  </button>
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustTime('startTime', 10, 'minute')">
                    <i class="material-icons">keyboard_arrow_up</i>
                  </button>
                </div>
                
                <!-- Zeitfeld -->
                <input class="mdl-textfield__input" type="time" id="startTime" style="margin-bottom: 4px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--card-bg-color); color: var(--text-color);">
                
                <!-- Abwärts-Buttons für Zeit -->
                <div style="display: flex; justify-content: space-between;">
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustTime('startTime', -1, 'hour')">
                    <i class="material-icons">arrow_downward</i>
                  </button>
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustTime('startTime', -10, 'minute')">
                    <i class="material-icons">keyboard_arrow_down</i>
                  </button>
                </div>
              </div>
            </div>
          </div>
          
          <div class="filter-group" style="display: flex; flex-direction: column; margin: 8px;">
            <label class="filter-label" style="font-size: 12px; margin-bottom: 4px; color: var(--secondary-text-color);">Enddatum und -zeit</label>
            <div style="display: flex; align-items: center;">
              <div style="display: flex; flex-direction: column; margin-right: 8px;">
                <!-- Aufwärts-Buttons für Datum -->
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustDate('endDate', 1, 'day')">
                    <i class="material-icons">arrow_upward</i>
                  </button>
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustDate('endDate', 1, 'month')">
                    <i class="material-icons">keyboard_arrow_up</i>
                  </button>
                </div>
                
                <!-- Datumsfeld -->
                <input class="mdl-textfield__input" type="date" id="endDate" style="margin-bottom: 4px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--card-bg-color); color: var(--text-color);">
                
                <!-- Abwärts-Buttons für Datum -->
                <div style="display: flex; justify-content: space-between;">
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustDate('endDate', -1, 'day')">
                    <i class="material-icons">arrow_downward</i>
                  </button>
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustDate('endDate', -1, 'month')">
                    <i class="material-icons">keyboard_arrow_down</i>
                  </button>
                </div>
              </div>
              
              <div style="display: flex; flex-direction: column;">
                <!-- Aufwärts-Buttons für Zeit -->
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustTime('endTime', 1, 'hour')">
                    <i class="material-icons">arrow_upward</i>
                  </button>
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustTime('endTime', 10, 'minute')">
                    <i class="material-icons">keyboard_arrow_up</i>
                  </button>
                </div>
                
                <!-- Zeitfeld -->
                <input class="mdl-textfield__input" type="time" id="endTime" style="margin-bottom: 4px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--card-bg-color); color: var(--text-color);">
                
                <!-- Abwärts-Buttons für Zeit -->
                <div style="display: flex; justify-content: space-between;">
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustTime('endTime', -1, 'hour')">
                    <i class="material-icons">arrow_downward</i>
                  </button>
                  <button class="mdl-button mdl-js-button mdl-button--icon" onclick="adjustTime('endTime', -10, 'minute')">
                    <i class="material-icons">keyboard_arrow_down</i>
                  </button>
                </div>
              </div>
            </div>
          </div>
          
          <div class="filter-item" style="display: flex; align-items: flex-end; margin: 8px;">
            <button class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--colored" onclick="applyDateFilter()" style="margin-right: 8px;">
              Filter anwenden
            </button>
            <button class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect" onclick="resetDateFilter()">
              Zurücksetzen
            </button>
          </div>
        </div>

        <!-- Übersicht Tab -->
        <div id="overview" class="tab-container active">
          <!-- Zusammenfassung -->
          <div class="mdl-grid summary-card mdl-shadow--2dp">
            <div class="summary-item">
              <div class="summary-value" id="totalFiles">-</div>
              <div class="summary-label">
                Dateien gesamt
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Gesamtanzahl aller verarbeiteten Dateien (Input + Archiv + Fehler)</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="errorCount">-</div>
              <div class="summary-label">
                Fehler
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Anzahl der aufgetretenen Fehler im ausgewählten Zeitraum</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="patternCount">-</div>
              <div class="summary-label">
                Muster erkannt
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Anzahl der Fehler, die einem bekannten Muster zugeordnet werden konnten</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="errorRate">-</div>
              <div class="summary-label">
                Fehlerrate
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Prozentualer Anteil der Fehler an der Gesamtzahl der Dateien</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="lastRunTime">-</div>
              <div class="summary-label">
                Letzte Ausführung
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Zeitpunkt der letzten Ausführung des AnyFileMonitors</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="systemStatus">
                <span class="status-indicator status-good" id="statusIndicator"></span>
                <span id="statusText">Gut</span>
              </div>
              <div class="summary-label">
                Systemstatus
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Aktueller Zustand des Systems basierend auf der Fehlerrate (Gut: <5%, Warnung: 5-10%, Kritisch: >10%)</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="inputFiles">-</div>
              <div class="summary-label">
                Input-Dateien
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Anzahl der Dateien, die aktuell im Input-Verzeichnis liegen</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="archiveFiles">-</div>
              <div class="summary-label">
                Archiv-Dateien
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Anzahl der Dateien, die erfolgreich verarbeitet und archiviert wurden</span>
                </span>
              </div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="errorFiles">-</div>
              <div class="summary-label">
                Fehler-Dateien
                <span class="tooltip">
                  <i class="material-icons info-icon">info_outline</i>
                  <span class="tooltiptext">Anzahl der Dateien, die nicht verarbeitet werden konnten und im Fehler-Verzeichnis liegen</span>
                </span>
              </div>
            </div>
          </div>

          <!-- System-Gesundheit -->
          <div class="mdl-grid">
            <div class="mdl-cell mdl-cell--4-col">
              <div class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">System-Gesundheit</h2>
                </div>
                <div class="mdl-card__supporting-text">
                  <div class="gauge-container">
                    <canvas id="healthGauge"></canvas>
                    <div class="gauge-label">Systemstatus</div>
                  </div>
                  <div style="margin-top: 16px; text-align: center;">
                    <span id="healthScore">100%</span> Gesundheit
                  </div>
                </div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--4-col">
              <div class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">Fehler-Verteilung</h2>
                </div>
                <div class="mdl-card__supporting-text">
                  <div class="small-chart-container">
                    <canvas id="errorTypePieChart"></canvas>
                  </div>
                </div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--4-col">
              <div class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">Top Fehler</h2>
                </div>
                <div class="mdl-card__supporting-text">
                  <div id="topErrorsList">Lädt...</div>
                </div>
              </div>
            </div>
          </div>

          <!-- KPI-Übersicht -->
          <div class="mdl-grid">
            <div class="mdl-cell mdl-cell--3-col">
              <div class="kpi-card">
                <div class="kpi-label">
                  Durchsatz (Dateien/Stunde)
                  <span class="tooltip">
                    <i class="material-icons info-icon">info_outline</i>
                    <span class="tooltiptext">Durchschnittliche Anzahl der verarbeiteten Dateien pro Stunde</span>
                  </span>
                </div>
                <div class="kpi-value" id="throughput">-</div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--3-col">
              <div class="kpi-card">
                <div class="kpi-label">
                  Archiv : Fehler
                  <span class="tooltip">
                    <i class="material-icons info-icon">info_outline</i>
                    <span class="tooltiptext">Verhältnis zwischen archivierten und fehlerhaften Dateien</span>
                  </span>
                </div>
                <div class="kpi-value" id="archiveToErrorRatio">-</div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--3-col">
              <div class="kpi-card">
                <div class="kpi-label">
                  Fehlerintensität
                  <span class="tooltip">
                    <i class="material-icons info-icon">info_outline</i>
                    <span class="tooltiptext">Durchschnittliche Anzahl der Fehler pro Stunde im ausgewählten Zeitraum</span>
                  </span>
                </div>
                <div class="kpi-value" id="errorIntensityKPI">-</div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--3-col">
              <div class="kpi-card">
                <div class="kpi-label">
                  Fehlertrend
                  <span class="tooltip">
                    <i class="material-icons info-icon">info_outline</i>
                    <span class="tooltiptext">Prozentuale Veränderung der Fehleranzahl im Vergleich zum vorherigen Zeitraum</span>
                  </span>
                </div>
                <div class="kpi-value" id="errorTrendKPI">-</div>
              </div>
            </div>
          </div>

          <!-- Fehler nach Tageszeit -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehler nach Tageszeit</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="errorsByHourChart"></canvas>
              </div>
            </div>
          </div>

          <!-- Fehler nach Wochentag -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehler nach Wochentag</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="errorsByWeekdayChart"></canvas>
              </div>
            </div>
          </div>
        </div>

        <!-- Status Tab -->
        <div id="status" class="tab-container">
          <!-- Status-Diagramme - Aufgeteilt in drei separate Diagramme -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Input-Verlauf</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="inputChart"></canvas>
              </div>
            </div>
          </div>

          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Archiv-Verlauf</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="archiveChart"></canvas>
              </div>
            </div>
          </div>

          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Error-Verlauf</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="errorChart"></canvas>
              </div>
            </div>
          </div>

          <!-- Status-Log -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Status-Log (AFM_status_log.csv)</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div id="statusTable" class="loading">
                <div class="mdl-spinner mdl-js-spinner is-active"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Analyse Tab -->
        <div id="analysis" class="tab-container">
          <!-- Fehler-Trend nach Typ -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehler-Trend nach Typ</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="errorTrendChart"></canvas>
              </div>
            </div>
          </div>
          
          <!-- Fehler-Verteilung nach Wochentagen -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehlertypen nach Wochentagen</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="errorHeatmapChart"></canvas>
              </div>
            </div>
          </div>
          
          <!-- Verarbeitungseffizienz -->
          <div class="mdl-grid">
            <div class="mdl-cell mdl-cell--6-col">
              <div class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">Fehlerrate-Verlauf</h2>
                </div>
                <div class="mdl-card__supporting-text">
                  <div class="small-chart-container">
                    <canvas id="errorRateChart"></canvas>
                  </div>
                </div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--6-col">
              <div class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">Durchsatz-Verlauf</h2>
                </div>
                <div class="mdl-card__supporting-text">
                  <div class="small-chart-container">
                    <canvas id="throughputChart"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Fehler Tab -->
        <div id="errors" class="tab-container">
          <input type="text" id="searchInput" placeholder="Nach Dateinamen oder Fehlermeldung suchen..." onkeyup="searchErrors()">
          
          <!-- Fehler-Log -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehler-Log (AFM_error_log.csv)</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div id="errorTable" class="loading">
                <div class="mdl-spinner mdl-js-spinner is-active"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Muster Tab -->
        <div id="patterns" class="tab-container">
          <!-- Muster-Treffer -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Erkannte Muster (AFM_pattern_matches.csv)</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div id="patternTable" class="loading">
                <div class="mdl-spinner mdl-js-spinner is-active"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Eingangsdaten Tab -->
        <div id="input" class="tab-container">
          <!-- Eingangsdetails -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Eingangsdetails (AFM_input_details.csv)</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div id="inputTable" class="loading">
                <div class="mdl-spinner mdl-js-spinner is-active"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- Refresh Button -->
  <button class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect mdl-button--colored refresh-button" onclick="loadAllData()">
    <i class="material-icons">refresh</i>
  </button>

  <script>
    // Globale Variablen
    let allStatusData = [];
    let allErrorData = [];
    let allPatternData = [];
    let allInputData = [];
    let filteredStatusData = [];
    let filteredErrorData = [];
    let filteredPatternData = [];
    let filteredInputData = [];
    let startDateFilter = null;
    let endDateFilter = null;
    let startTimeFilter = null;
    let endTimeFilter = null;
    
    // Bekannte Fehlermuster aus config.ini - wird dynamisch geladen
    let knownErrorPatterns = [];

    // Konfiguration aus config.ini laden
    function loadConfig() {
      fetch('./config.ini')
        .then(response => {
          if (!response.ok) {
            throw new Error('Fehler beim Laden der Konfiguration');
          }
          return response.text();
        })
        .then(configText => {
          // config.ini parsen
          const configLines = configText.split('\n');
          let errorPatterns = '';
          
          // Nach der errorPatterns-Zeile suchen
          for (const line of configLines) {
            if (line.trim().startsWith('errorPatterns=')) {
              errorPatterns = line.trim().substring('errorPatterns='.length);
              break;
            }
          }
          
          // Muster aufteilen und in Array speichern
          knownErrorPatterns = errorPatterns.split(',').map(pattern => pattern.trim());
          console.log('Geladene Fehlermuster:', knownErrorPatterns);
          
          // Nach dem Laden der Konfiguration die Daten aktualisieren
          loadAllData();
        })
        .catch(error => {
          console.error('Fehler beim Laden der config.ini:', error);
          // Fallback zu Default-Werten
          knownErrorPatterns = [
            "Timeout", 
            "Zeitüberschreitung", 
            "Verbindung vom peer", 
            "multiple Rows in singleton select", 
            "deadlock", 
            "lock conflict on no wait transaction",
            "nicht definiert"
          ];
          loadAllData();
        });
    }

    // Datumsfilter initialisieren
    function initDateFilter() {
      // Heutiges Datum
      const today = new Date();
      const todayFormatted = today.toISOString().split('T')[0]; // YYYY-MM-DD Format
      
      // Gestriges Datum
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayFormatted = yesterday.toISOString().split('T')[0]; // YYYY-MM-DD Format
      
      // Eingabefelder mit den Werten füllen
      document.getElementById('startDate').value = yesterdayFormatted;
      document.getElementById('endDate').value = todayFormatted;
      
      // Uhrzeitwerte setzen (00:00 für Start, 23:59 für Ende)
      document.getElementById('startTime').value = '00:00';
      document.getElementById('endTime').value = '23:59';
      
      // Filter-Variablen setzen
      startDateFilter = new Date(yesterday);
      startDateFilter.setHours(0, 0, 0, 0); // Beginn des Tages (00:00:00)
      
      endDateFilter = new Date(today);
      endDateFilter.setHours(23, 59, 59, 999); // Ende des Tages (23:59:59)
      
      // Filter automatisch anwenden, ohne Klick auf den Button zu erfordern
      applyFilters();
      processAllData();
    }

    // Tab-Steuerung
    function showTab(tabId) {
      // Alle Tabs verstecken
      document.querySelectorAll('.tab-container').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Ausgewählten Tab anzeigen
      document.getElementById(tabId).classList.add('active');
      
      // Aktivität in der Navigation markieren
      document.querySelectorAll('.mdl-navigation__link').forEach(link => {
        if (link.getAttribute('href') === '#' + tabId) {
          link.classList.add('is-active');
        } else {
          link.classList.remove('is-active');
        }
      });
    }

    // Datum-Filter anwenden
    function applyDateFilter() {
      const startInput = document.getElementById('startDate');
      const endInput = document.getElementById('endDate');
      const startTimeInput = document.getElementById('startTime');
      const endTimeInput = document.getElementById('endTime');
      
      // Vollständige Zeitstempel erstellen, die Datum und Uhrzeit kombinieren
      if (startInput.value) {
        const startDate = new Date(startInput.value);
        if (startTimeInput.value) {
          const [hours, minutes] = startTimeInput.value.split(':');
          startDate.setHours(parseInt(hours), parseInt(minutes), 0);
        } else {
          startDate.setHours(0, 0, 0); // Beginn des Tages, wenn keine Zeit angegeben
        }
        startDateFilter = startDate;
      } else {
        startDateFilter = null;
      }
      
      if (endInput.value) {
        const endDate = new Date(endInput.value);
        if (endTimeInput.value) {
          const [hours, minutes] = endTimeInput.value.split(':');
          endDate.setHours(parseInt(hours), parseInt(minutes), 59);
        } else {
          endDate.setHours(23, 59, 59); // Ende des Tages, wenn keine Zeit angegeben
        }
        endDateFilter = endDate;
      } else {
        endDateFilter = null;
      }
      
      console.log("Start filter:", startDateFilter);
      console.log("End filter:", endDateFilter);
      
      applyFilters();
      processAllData();
    }

    // Datum-Filter zurücksetzen
    function resetDateFilter() {
      document.getElementById('startDate').value = '';
      document.getElementById('endDate').value = '';
      document.getElementById('startTime').value = '';
      document.getElementById('endTime').value = '';
      startDateFilter = null;
      endDateFilter = null;
      
      applyFilters();
      processAllData();
    }

    // Filter auf Daten anwenden
    function applyFilters() {
      filteredStatusData = filterDataByDate(allStatusData);
      filteredErrorData = filterDataByDate(allErrorData);
      filteredPatternData = filterDataByDate(allPatternData);
      filteredInputData = filterDataByDate(allInputData);
    }

    // Datum-Filter anwenden
    function filterDataByDate(data) {
      if (!startDateFilter && !endDateFilter) {
        return [...data]; // Kopie des Arrays zurückgeben, wenn kein Filter aktiv
      }
      
      return data.filter(row => {
        if (!row.Zeitpunkt) return true;
        
        // Zeitstempel aus dem Datensatz parsen
        const [datePart, timePart] = row.Zeitpunkt.split(' ');
        const [year, month, day] = datePart.split('-').map(num => parseInt(num));
        const [hours, minutes, seconds] = timePart.split(':').map(num => parseInt(num));
        
        // JavaScript Monate sind 0-basiert (0 = Januar)
        const rowDate = new Date(year, month - 1, day, hours, minutes, seconds);
        
        if (startDateFilter && rowDate < startDateFilter) return false;
        if (endDateFilter && rowDate > endDateFilter) return false;
        
        return true;
      });
    }

    // Fehlertabelle durchsuchen
    function searchErrors() {
      const searchTerm = document.getElementById('searchInput').value.toLowerCase();
      const errorTable = document.getElementById('errorTable');
      
      if (!errorTable) return;
      
      const rows = errorTable.querySelectorAll('tbody tr');
      
      rows.forEach(row => {
        const rowText = row.textContent.toLowerCase();
        if (rowText.includes(searchTerm)) {
          row.style.display = '';
        } else {
          row.style.display = 'none';
        }
      });
    }

    // Hauptfunktion zum Laden aller Daten anpassen
    function loadAllData() {
      document.getElementById('lastUpdate').textContent = 'Letzte Aktualisierung: ' + new Date().toLocaleString('de-DE');
      
      // Promise-basierte Verarbeitung der Daten
      Promise.all([
        new Promise(resolve => loadCSV('./AFM_status_log.csv', results => {
          allStatusData = results.data || [];
          resolve();
        })),
        new Promise(resolve => loadCSV('./AFM_error_log.csv', results => {
          allErrorData = results.data || [];
          resolve();
        })),
        new Promise(resolve => loadCSV('./AFM_pattern_matches.csv', results => {
          allPatternData = results.data || [];
          resolve();
        })),
        new Promise(resolve => loadCSV('./AFM_input_details.csv', results => {
          allInputData = results.data || [];
          resolve();
        }))
      ]).then(() => {
        // Nach dem Laden aller Daten Filter anwenden
        applyFilters();
        processAllData();
      });
    }

    function processAllData() {
      processStatusData({ data: filteredStatusData });
      processErrorData({ data: filteredErrorData });
      processPatternData({ data: filteredPatternData });
      processInputData({ data: filteredInputData });
      
      // Zusätzliche Analysen
      calculateKPIs();
      createErrorTrendChart();
      createErrorRateChart();
      createThroughputChart();
      createErrorsByHourChart();
      createErrorTypePieChart();
      updateTopErrorsList();
      updateSystemHealthGauge();
      createErrorsByWeekdayChart();
      createErrorsByWeekdayStackedChart(); // Neue Funktion
    }

    function loadCSV(file, callback) {
      Papa.parse(file, {
        download: true,
        header: true,
        delimiter: ";", // Semikolon als Trennzeichen festlegen
        skipEmptyLines: true,
        complete: callback
      });
    }

    // Status-Daten verarbeiten
    function processStatusData(results) {
      if (!results.data || results.data.length === 0) {
        document.getElementById('statusTable').innerHTML = '<p>Keine Status-Daten verfügbar.</p>';
        return;
      }

      // Tabelle erstellen
      renderTable(results.data, 'statusTable');

      // Letzte Ausführung anzeigen
      const lastRun = results.data[results.data.length - 1];
      if (lastRun && lastRun.Zeitpunkt) {
        document.getElementById('lastRunTime').textContent = lastRun.Zeitpunkt.split(' ')[1] || '-';
      }

      // Berechne die Summen für den Filterzeitraum
      if (results.data.length > 0) {
        // Für Input, Error und Archiv den höchsten Wert im gefilterten Zeitraum nehmen
        let inputVal = 0;
        let errorVal = 0;
        let archiveVal = 0;
        
        // Den letzten Eintrag im gefilterten Zeitraum verwenden
        const lastEntry = results.data[results.data.length - 1];
        
        // Werte aus dem letzten Eintrag extrahieren und sicherstellen, dass sie gültige Zahlen sind
        inputVal = parseInt(lastEntry['Input'] || 0);
        errorVal = parseInt(lastEntry['Error'] || 0);
        archiveVal = parseInt(lastEntry['Archiv'] || 0);
        
        // Sicherstellen, dass keine negativen Werte verwendet werden
        inputVal = Math.max(0, inputVal);
        errorVal = Math.max(0, errorVal);
        archiveVal = Math.max(0, archiveVal);
        
        // Werte anzeigen
        document.getElementById('inputFiles').textContent = inputVal;
        document.getElementById('errorFiles').textContent = errorVal;
        document.getElementById('archiveFiles').textContent = archiveVal;
        
        // Gesamtzahl der Dateien berechnen durch einfache Addition
        const totalFiles = inputVal + errorVal + archiveVal;
        document.getElementById('totalFiles').textContent = totalFiles;
        
        // Fehlerrate berechnen basierend auf den gefilterten Fehlerdaten
        calculateErrorRate();
      }

      // Daten für die Charts vorbereiten
      const labels = [];
      const inputData = [];
      const errorData = [];
      const archiveData = [];

      // Daten aus den Ergebnissen extrahieren
      results.data.forEach(entry => {
        if (entry.Zeitpunkt) {
          labels.push(entry.Zeitpunkt);
          inputData.push(parseInt(entry['Input'] || 0));
          errorData.push(parseInt(entry['Error'] || 0));
          archiveData.push(parseInt(entry['Archiv'] || 0));
        }
      });

      // Input-Chart erstellen
      const ctxInput = document.getElementById('inputChart').getContext('2d');
      if (window.inputChart instanceof Chart) {
        window.inputChart.destroy();
      }
      
      window.inputChart = new Chart(ctxInput, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Input',
              data: inputData,
              borderColor: 'rgba(54, 162, 235, 1)',
              backgroundColor: 'rgba(54, 162, 235, 0.2)',
              tension: 0.1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Dateien'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Zeitpunkt'
              }
            }
          }
        }
      });

      // Error-Chart erstellen
      const ctxError = document.getElementById('errorChart').getContext('2d');
      if (window.errorChart instanceof Chart) {
        window.errorChart.destroy();
      }
      
      window.errorChart = new Chart(ctxError, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Fehler',
              data: errorData,
              borderColor: 'rgba(255, 99, 132, 1)',
              backgroundColor: 'rgba(255, 99, 132, 0.2)',
              tension: 0.1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Fehler'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Zeitpunkt'
              }
            }
          }
        }
      });

      // Archiv-Chart erstellen
      const ctxArchive = document.getElementById('archiveChart').getContext('2d');
      if (window.archiveChart instanceof Chart) {
        window.archiveChart.destroy();
      }
      
      window.archiveChart = new Chart(ctxArchive, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Archiv',
              data: archiveData,
              borderColor: 'rgba(75, 192, 192, 1)',
              backgroundColor: 'rgba(75, 192, 192, 0.2)',
              tension: 0.1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Dateien'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Zeitpunkt'
              }
            }
          }
        }
      });
    }

    // Systemstatus aktualisieren
    function updateSystemStatus(errorRate) {
      const rateValue = parseFloat(errorRate);
      const indicator = document.getElementById('statusIndicator');
      const statusText = document.getElementById('statusText');
      
      if (rateValue < 5) {
        indicator.className = 'status-indicator status-good';
        statusText.textContent = 'Gut';
      } else if (rateValue < 10) {
        indicator.className = 'status-indicator status-warning';
        statusText.textContent = 'Warnung';
      } else {
        indicator.className = 'status-indicator status-error';
        statusText.textContent = 'Kritisch';
      }
    }

    // Fehler-Daten verarbeiten
    function processErrorData(results) {
      if (!results.data || results.data.length === 0) {
        document.getElementById('errorTable').innerHTML = '<p>Keine Fehler-Daten verfügbar.</p>';
        return;
      }

      document.getElementById('errorCount').textContent = results.data.length;
      renderTable(results.data, 'errorTable', true);
      
      // Fehlerrate wird nun zentral in calculateErrorRate() berechnet
      calculateErrorRate();
    }

    // Zentrale Funktion für die Berechnung der Fehlerrate
    function calculateErrorRate() {
      // Prüfen ob genügend Daten vorhanden sind
      if (filteredStatusData.length < 1) return;
        
      // Berechne die tatsächlich verarbeiteten Dateien während des Zeitraums
      let processedFiles = 0;
      let errorFiles = 0;
      
      if (filteredStatusData.length > 1) {
        // Differenz zwischen Anfang und Ende des Zeitraums
        const firstEntry = filteredStatusData[0];
        const lastEntry = filteredStatusData[filteredStatusData.length - 1];
        
        // Berechne die Veränderung im Archiv und Fehlerverzeichnis
        const archiveChange = parseInt(lastEntry['Archiv'] || 0) - parseInt(firstEntry['Archiv'] || 0);
        const errorChange = parseInt(lastEntry['Error'] || 0) - parseInt(firstEntry['Error'] || 0);
        
        // Die Anzahl der Fehlerdateien ist die positive Änderung im Fehlerverzeichnis
        errorFiles = Math.max(0, errorChange);
        
        // Die Summe der positiven Änderungen stellt die verarbeiteten Dateien dar
        processedFiles = Math.max(0, archiveChange) + errorFiles;
      } else {
        // Fallback für einzelnen Datenpunkt
        const singleEntry = filteredStatusData[0];
        processedFiles = parseInt(singleEntry['Error'] || 0) + parseInt(singleEntry['Archiv'] || 0);
        errorFiles = parseInt(singleEntry['Error'] || 0);
      }
      
      // Für Perioden, in denen nur Fehlerdateien verarbeitet wurden
      const errorCount = filteredErrorData.length;
      
      // Wenn keine Änderung oder negative Änderung (z.B. durch Dateilöschungen), verwenden wir die Fehleranzahl
      if (processedFiles === 0) {
        processedFiles = errorCount > 0 ? errorCount : 1; // Vermeidet Division durch Null
        errorFiles = errorCount;
      }
      
      // Wenn alle verarbeiteten Dateien Fehler sind und die Anzahl der Fehler mit errorFiles übereinstimmt,
      // dann haben wir eine 100% Fehlerrate
      if (processedFiles > 0 && processedFiles === errorFiles) {
        document.getElementById('errorRate').textContent = '100.0%';
        updateSystemStatus('100.0%');
        return '100.0%';
      }
      
      // Fehlerrate berechnen als Prozentsatz
      const errorRate = ((errorCount / processedFiles) * 100).toFixed(1) + '%';
      document.getElementById('errorRate').textContent = errorRate;
      
      // Systemstatus aktualisieren
      updateSystemStatus(errorRate);
      
      return errorRate;
    }

    // Muster-Daten verarbeiten
    function processPatternData(results) {
      if (!results.data || results.data.length === 0) {
        document.getElementById('patternTable').innerHTML = '<p>Keine Muster-Daten verfügbar.</p>';
        return;
      }

      document.getElementById('patternCount').textContent = results.data.length;
      renderTable(results.data, 'patternTable', true);
    }

    // Eingangs-Daten verarbeiten
    function processInputData(results) {
      if (!results.data || results.data.length === 0) {
        document.getElementById('inputTable').innerHTML = '<p>Keine Eingangs-Daten verfügbar.</p>';
        return;
      }

      renderTable(results.data, 'inputTable');
      document.getElementById('inputFiles').textContent = results.data.length;
      
      // Aktualisiere den Input-Files-Count in der Übersicht mit dem letzten Wert
      if (results.data.length > 0) {
        const latestInputData = results.data[results.data.length - 1];
        document.getElementById('inputFiles').textContent = latestInputData['Anzahl'];
      }
    }

    // Durchsatz berechnen als Differenz zwischen den letzten beiden Messungen
    function calculateThroughput(statusData) {
      if (statusData.length < 2) {
        return 0;
      }
      
      // Letzter und vorletzter Eintrag
      const lastEntry = statusData[statusData.length - 1];
      const prevEntry = statusData[statusData.length - 2];
      
      // Summe der verarbeiteten Dateien (Archiv + Error) für jede Messung
      const lastProcessed = parseInt(lastEntry['Archiv'] || 0) + parseInt(lastEntry['Error'] || 0);
      const prevProcessed = parseInt(prevEntry['Archiv'] || 0) + parseInt(prevEntry['Error'] || 0);
      
      // Differenz = Anzahl der neu verarbeiteten Dateien
      const processedDifference = lastProcessed - prevProcessed;
      
      // Zeitdifferenz in Stunden berechnen
      const lastTime = new Date(lastEntry.Zeitpunkt);
      const prevTime = new Date(prevEntry.Zeitpunkt);
      const hoursDiff = (lastTime - prevTime) / (1000 * 60 * 60); // Millisekunden in Stunden umrechnen
      
      // Durchsatz pro Stunde (hochgerechnet, falls das Intervall kürzer als eine Stunde ist)
      const throughputPerHour = hoursDiff > 0 ? Math.round(processedDifference / hoursDiff) : 0;
      
      return throughputPerHour;
    }

    // KPIs berechnen
    function calculateKPIs() {
      if (filteredStatusData.length < 2) return;

      // Fehlerintensität (Fehler pro Stunde)
      function calculateErrorIntensity() {
        if (filteredErrorData.length === 0) return "0";

        const startTime = startDateFilter ? startDateFilter.getTime() : new Date(filteredErrorData[0].Zeitpunkt).getTime();
        const endTime = endDateFilter ? endDateFilter.getTime() : new Date(filteredErrorData[filteredErrorData.length - 1].Zeitpunkt).getTime();

        const hours = Math.max(0.01, (endTime - startTime) / (1000 * 60 * 60));
        return (filteredErrorData.length / hours).toFixed(1);
      }

      // Fehlertrend (prozentuale Veränderung zum vorherigen Zeitraum)
      function calculateErrorTrend() {
        if (filteredErrorData.length === 0 || !startDateFilter || !endDateFilter) return "0%";

        const currentPeriodLength = endDateFilter.getTime() - startDateFilter.getTime();
        const prevPeriodStart = new Date(startDateFilter.getTime() - currentPeriodLength);
        const prevPeriodEnd = new Date(startDateFilter.getTime());

        const currentErrors = filteredErrorData.length;
        const prevErrors = allErrorData.filter(entry => {
          if (!entry.Zeitpunkt) return false;
          const timestamp = new Date(entry.Zeitpunkt).getTime();
          return timestamp >= prevPeriodStart.getTime() && timestamp <= prevPeriodEnd.getTime();
        }).length;

        if (prevErrors === 0 && currentErrors === 0) return "0%";
        if (prevErrors === 0) return currentErrors > 0 ? "+∞%" : "0%";

        const change = ((currentErrors - prevErrors) / prevErrors) * 100;
        const sign = change > 0 ? "+" : "";
        return `${sign}${change.toFixed(1)}%`;
      }

      // Fehlerintensität berechnen und anzeigen
      const errorIntensity = calculateErrorIntensity();
      document.getElementById('errorIntensityKPI').textContent = errorIntensity;

      // Fehlertrend berechnen und anzeigen
      const errorTrend = calculateErrorTrend();
      document.getElementById('errorTrendKPI').textContent = errorTrend;

      // Durchsatz-Berechnung
      const throughputPerHour = calculateThroughput(filteredStatusData);
      document.getElementById('throughput').textContent = throughputPerHour;
      
      // Archiv zu Fehler Verhältnis
      const lastEntry = filteredStatusData[filteredStatusData.length - 1];
      const archiveCount = parseInt(lastEntry['Archiv'] || 0);
      const errorCount = parseInt(lastEntry['Error'] || 0);
      
      let ratio;
      if (errorCount === 0 && archiveCount === 0) {
        ratio = "N/A";
      } else if (errorCount === 0) {
        ratio = "∞";
      } else if (archiveCount === 0) {
        ratio = "0:1";
      } else {
        const gcd = findGCD(archiveCount, errorCount);
        ratio = (archiveCount / gcd) + ":" + (errorCount / gcd);
      }
      
      document.getElementById('archiveToErrorRatio').textContent = ratio;
    }
    
    // Größter gemeinsamer Teiler für Verhältnisberechnung
    function findGCD(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      while(b) {
        let t = b;
        b = a % b;
        a = t;
      }
      return a;
    }

    // Fehler-Trend nach Typ erstellen
    function createErrorTrendChart() {
      if (filteredPatternData.length === 0) return;
      
      // Daten nach 15-Minuten-Intervall und Muster gruppieren (statt nach Stunde)
      const errorTypesByInterval = {};
      const errorTypes = new Set();
      
      filteredPatternData.forEach(entry => {
        if (!entry.Zeitpunkt) return;
        
        // Zeitpunkt zerlegen, um Stunde und Minute zu extrahieren
        const [datePart, timePart] = entry.Zeitpunkt.split(' ');
        const [hour, minute] = timePart.split(':');
        
        // Minute auf das nächste 15-Minuten-Intervall abrunden
        const intervalMinute = Math.floor(parseInt(minute) / 15) * 15;
        const formattedMinute = intervalMinute.toString().padStart(2, '0');
        
        // Formatierter Zeitstempel für 15-Minuten-Intervalle
        const formattedDateTime = `${datePart} ${hour}:${formattedMinute}`;
        const pattern = entry.Muster;
        
        if (!errorTypesByInterval[formattedDateTime]) {
          errorTypesByInterval[formattedDateTime] = {};
        }
        
        if (!errorTypesByInterval[formattedDateTime][pattern]) {
          errorTypesByInterval[formattedDateTime][pattern] = 0;
        }
        
        errorTypesByInterval[formattedDateTime][pattern]++;
        errorTypes.add(pattern);
      });
      
      // Daten für Chart.js vorbereiten
      const labels = Object.keys(errorTypesByInterval).sort();
      const datasets = [];
      
      // Farben für verschiedene Fehlertypen
      const colors = [
        'rgba(255, 99, 132, 1)',
        'rgba(54, 162, 235, 1)',
        'rgba(255, 206, 86, 1)',
        'rgba(75, 192, 192, 1)',
        'rgba(153, 102, 255, 1)',
        'rgba(255, 159, 64, 1)'
      ];
      
      // Ein Dataset pro Fehlertyp erstellen
      Array.from(errorTypes).forEach((type, index) => {
        const data = labels.map(interval => errorTypesByInterval[interval][type] || 0);
        
        datasets.push({
          label: type,
          data: data,
          borderColor: colors[index % colors.length],
          backgroundColor: colors[index % colors.length].replace('1)', '0.2)'),
          tension: 0.1
        });
      });
      
      // Chart erstellen
      const ctx = document.getElementById('errorTrendChart').getContext('2d');
      if (window.errorTrendChart instanceof Chart) {
        window.errorTrendChart.destroy();
      }
      
      window.errorTrendChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Fehler'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Datum und Zeit (15-Min-Intervall)'
              },
              ticks: {
                maxRotation: 45,
                minRotation: 45
              }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                title: function(context) {
                  // Formatierung des Tooltip-Titels für bessere Lesbarkeit
                  return context[0].label;
                }
              }
            }
          }
        }
      });
    }

    // Fehlerrate-Diagramm erstellen
    function createErrorRateChart() {
      if (filteredStatusData.length === 0) return;
      
      const labels = [];
      const errorRates = [];
      
      filteredStatusData.forEach(entry => {
        const total = parseInt(entry['Input'] || 0) + 
                       parseInt(entry['Archiv'] || 0) + 
                       parseInt(entry['Error'] || 0);
        const errorCount = parseInt(entry['Error'] || 0);
        const errorRate = total > 0 ? (errorCount / total) * 100 : 0;
        
        labels.push(entry.Zeitpunkt.split(' ')[1]);
        errorRates.push(errorRate);
      });
      
      // Chart erstellen
      const ctx = document.getElementById('errorRateChart').getContext('2d');
      if (window.errorRateChart instanceof Chart) {
        window.errorRateChart.destroy();
      }
      
      window.errorRateChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Fehlerrate (%)',
            data: errorRates,
            borderColor: 'rgba(255, 99, 132, 1)',
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Fehlerrate (%)'
              }
            }
          }
        }
      });
    }

    // Durchsatz-Diagramm erstellen
    function createThroughputChart() {
      if (filteredStatusData.length === 0) return;
      
      const labels = [];
      const throughputData = [];
      
      filteredStatusData.forEach(entry => {
        const total = parseInt(entry['Input'] || 0) + 
                       parseInt(entry['Archiv'] || 0) + 
                       parseInt(entry['Error'] || 0);
        
        labels.push(entry.Zeitpunkt.split(' ')[1]);
        throughputData.push(total);
      });
      
      // Chart erstellen
      const ctx = document.getElementById('throughputChart').getContext('2d');
      if (window.throughputChart instanceof Chart) {
        window.throughputChart.destroy();
      }
      
      window.throughputChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Dateien pro Intervall',
            data: throughputData,
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Dateien'
              }
            }
          }
        }
      });
    }

    // Fehler nach Stunde erstellen
    function createErrorsByHourChart() {
      if (filteredErrorData.length === 0) return;
      
      // Fehler nach Stunde gruppieren
      const errorsByHour = Array(24).fill(0);
      
      filteredErrorData.forEach(entry => {
        if (entry.Zeitpunkt) {
          const hour = parseInt(entry.Zeitpunkt.split(' ')[1].split(':')[0]);
          if (!isNaN(hour) && hour >= 0 && hour < 24) {
            errorsByHour[hour]++;
          }
        }
      });
      
      // Labels erstellen (0-23 Uhr)
      const labels = Array.from({length: 24}, (_, i) => `${i}:00`);
      
      // Chart erstellen
      const ctx = document.getElementById('errorsByHourChart').getContext('2d');
      if (window.errorsByHourChart instanceof Chart) {
        window.errorsByHourChart.destroy();
      }
      
      window.errorsByHourChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Fehler pro Stunde',
            data: errorsByHour,
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Fehler'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Stunde des Tages'
              }
            }
          }
        }
      });
    }

    // Fehler nach Wochentag erstellen
    function createErrorsByWeekdayChart() {
      if (filteredErrorData.length === 0) return;
      
      // Fehler nach Wochentag gruppieren
      const errorsByWeekday = Array(7).fill(0);
      
      filteredErrorData.forEach(entry => {
        if (entry.Zeitpunkt) {
          const [datePart] = entry.Zeitpunkt.split(' ');
          const [year, month, day] = datePart.split('-').map(num => parseInt(num));
          const date = new Date(year, month-1, day);
          const weekday = date.getDay(); // 0 = Sonntag, 1 = Montag, ...
          errorsByWeekday[weekday]++;
        }
      });
      
      // Wochentagsnamen
      const weekdays = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
      
      // Chart erstellen
      const ctx = document.getElementById('errorsByWeekdayChart').getContext('2d');
      if (window.errorsByWeekdayChart instanceof Chart) {
        window.errorsByWeekdayChart.destroy();
      }
      
      window.errorsByWeekdayChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: weekdays,
          datasets: [{
            label: 'Fehler pro Wochentag',
            data: errorsByWeekday,
            backgroundColor: 'rgba(153, 102, 255, 0.2)',
            borderColor: 'rgba(153, 102, 255, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Fehler'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Wochentag'
              }
            }
          }
        }
      });
    }

    // Fehlertypen nach Wochentag als gestapeltes Balkendiagramm
    function createErrorsByWeekdayStackedChart() {
      // Genau dieselbe Logik wie bei updateTopErrorsList() verwenden
      if (filteredPatternData.length === 0) return;
      
      // Bestehendes Diagramm zerstören, falls vorhanden
      if (window.errorsByWeekdayChart instanceof Chart) {
        window.errorsByWeekdayChart.destroy();
        window.errorsByWeekdayChart = null;
      }
      
      const ctx = document.getElementById('errorHeatmapChart').getContext('2d');
      
      // Fehler nach Muster gruppieren und zählen, genau wie bei der Top-Fehler-Liste
      const errorsByType = {};
      filteredPatternData.forEach(entry => {
        const pattern = entry.Muster;
        if (!errorsByType[pattern]) {
          errorsByType[pattern] = {
            total: 0,
            byWeekday: [0, 0, 0, 0, 0, 0, 0]  // So, Mo, Di, Mi, Do, Fr, Sa
          };
        }
        
        // Gesamtzahl für den Fehlertyp erhöhen
        errorsByType[pattern].total++;
        
        // Wochentag bestimmen und entsprechenden Zähler erhöhen
        if (entry.Zeitpunkt) {
          const [datePart] = entry.Zeitpunkt.split(' ');
          const [year, month, day] = datePart.split('-').map(num => parseInt(num));
          const date = new Date(year, month - 1, day);
          const weekday = date.getDay(); // 0 = Sonntag, 1 = Montag, ...
          errorsByType[pattern].byWeekday[weekday]++;
        }
      });
      
      // Nach Gesamtzahl sortieren, genau wie bei der Top-Fehler-Liste
      const sortedErrors = Object.entries(errorsByType)
        .sort((a, b) => b[1].total - a[1].total);
      
      console.log("Fehlerverteilung nach Muster:", sortedErrors);
      
      // Bis zu 10 häufigste Fehler für das Diagramm verwenden
      const topErrors = sortedErrors.slice(0, 10);
      const labels = topErrors.map(err => err[0]); // Fehlermuster
      
      // Transformiere die Daten für das gestapelte Balkendiagramm
      // (7 Wochentage x bis zu 10 Fehlertypen)
      const weekdays = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
      const datasets = [];
      
      // Kräftigere Farben für die Fehlertypen
      const colors = [
        'rgba(102, 153, 204, 0.85)',   // Kräftigeres Blau
        'rgba(140, 140, 140, 0.85)',   // Dunkleres Grau
        'rgba(120, 177, 120, 0.85)',   // Kräftigeres Grün
        'rgba(204, 120, 120, 0.85)',   // Kräftigeres Rosa
        'rgba(160, 120, 204, 0.85)',   // Kräftigeres Lila
        'rgba(204, 180, 80, 0.85)',    // Kräftigeres Gelb
        'rgba(80, 180, 204, 0.85)',    // Kräftigeres Türkis
        'rgba(194, 135, 80, 0.85)',    // Kräftigeres Hellbraun
        'rgba(110, 150, 204, 0.85)',   // Kräftigeres Hellblau
        'rgba(204, 160, 110, 0.85)'    // Kräftigeres Sand
      ];
      
      // Für jeden Fehlertyp ein Dataset erstellen
      topErrors.forEach((error, index) => {
        const [errorType, data] = error;
        const color = colors[index % colors.length]; // Verwende die kräftigeren Farben
        
        datasets.push({
          label: errorType,
          data: data.byWeekday,
          backgroundColor: color,
          borderColor: color.replace('0.85)', '1)'),
          borderWidth: 1
        });
      });
      
      try {
        // Erzeuge ein gestapeltes Balkendiagramm für die Fehlerverteilung nach Wochentag
        window.errorsByWeekdayChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: weekdays,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                title: {
                  display: true,
                  text: 'Wochentag'
                },
                stacked: true
              },
              y: {
                title: {
                  display: true,
                  text: 'Anzahl der Fehler'
                },
                stacked: true,
                beginAtZero: true
              }
            },
            plugins: {
              title: {
                display: true,
                text: 'Fehlertypen nach Wochentagen',
                font: {
                  size: 16
                }
              },
              tooltip: {
                callbacks: {
                  title: function(context) {
                    return context[0].label;
                  },
                  label: function(context) {
                    const label = context.dataset.label || '';
                    const value = context.raw || 0;
                    return `${label}: ${value} Fehler`;
                  },
                  footer: function(context) {
                    // Summe aller Fehler für diesen Wochentag anzeigen
                    const weekdayIndex = context[0].dataIndex;
                    let total = 0;
                    context.forEach(item => {
                      total += item.raw || 0;
                    });
                    return `Gesamt: ${total} Fehler`;
                  }
                }
              }
            }
          }
        });
      } catch (error) {
        console.error("Fehler beim Erstellen des Fehlertypen-Wochentag-Diagramms:", error);
      }
    }

    // Top Fehler-Liste aktualisieren
    function updateTopErrorsList() {
      const container = document.getElementById('topErrorsList');
      if (!container || filteredPatternData.length === 0) {
        if (container) container.innerHTML = 'Keine Daten verfügbar';
        return;
      }
      
      // Fehler nach Muster gruppieren und zählen
      const errorsByType = {};
      
      filteredPatternData.forEach(entry => {
        const pattern = entry.Muster;
        
        if (!errorsByType[pattern]) {
          errorsByType[pattern] = 0;
        }
        
        errorsByType[pattern]++;
      });
      
      // Nach Anzahl sortieren und die Top 10 nehmen
      const sortedErrors = Object.entries(errorsByType)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      // HTML für die Liste erstellen
      const html = sortedErrors.map((error, index) => {
        return `
          <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
            <div>${index + 1}. ${error[0]}</div>
            <div><strong>${error[1]}</strong></div>
          </div>
        `;
      }).join('');
      
      container.innerHTML = html || 'Keine Fehler gefunden';
    }

    // System-Gesundheit Gauge aktualisieren
    function updateSystemHealthGauge() {
    if (filteredStatusData.length === 0) return;
    
    // Use the central error rate calculation function
    const errorRateString = calculateErrorRate();
    
    // Parse the error rate from the returned string (removes the % sign)
    const errorRateValue = parseFloat(errorRateString) || 0;
    
    // Gesundheit berechnen: 100% - Fehlerrate
    const healthPercentage = Math.max(0, 100 - errorRateValue);
    
    // Gesundheitspunktzahl anzeigen
    document.getElementById('healthScore').textContent = healthPercentage.toFixed(1) + '%';
    
    // Rest of the gauge creation code remains unchanged
    const ctx = document.getElementById('healthGauge').getContext('2d');
    if (window.healthGauge instanceof Chart) {
      window.healthGauge.destroy();
    }
    
    // Farbe basierend auf Gesundheit
    let color = 'rgba(75, 192, 192, 1)'; // Grün
    if (healthPercentage < 90) {
      color = 'rgba(255, 206, 86, 1)'; // Gelb
    }
    if (healthPercentage < 80) {
      color = 'rgba(255, 99, 132, 1)'; // Rot
    }
    
  window.healthGauge = new Chart(ctx, {
        type: 'doughnut',
        data: {
          datasets: [{
            data: [healthPercentage, 100 - healthPercentage],
            backgroundColor: [
              color,
              'rgba(200, 200, 200, 0.2)'
            ],
            circumference: 180,
            rotation: 270
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutout: '70%',
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              enabled: false
            }
          }
        }
      });
    }

    // Tabelle rendern
    function renderTable(data, containerId, highlightErrors = false) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';

      if (!data || data.length === 0) {
        container.innerHTML = '<p>Keine Daten verfügbar.</p>';
        return;
      }

      // Tabelle erstellen
      const table = document.createElement('table');
      table.className = 'mdl-data-table mdl-js-data-table mdl-shadow--2dp';
      
      // Header erstellen
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      
      // Spaltenüberschriften aus dem ersten Datensatz
      const headers = Object.keys(data[0]);
      headers.forEach(header => {
        const th = document.createElement('th');
        th.className = 'mdl-data-table__cell--non-numeric';
        th.textContent = header;
        headerRow.appendChild(th);
      });
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Tabellenkörper erstellen
      const tbody = document.createElement('tbody');
      
      // Nur die letzten 100 Einträge anzeigen, um die Leistung zu verbessern
      const displayData = data.length > 100 ? data.slice(-100) : data;
      
      displayData.forEach(row => {
        const tr = document.createElement('tr');
        
        // Zeile hervorheben, wenn sie einen Fehler enthält
        if (highlightErrors && row.Muster) {
          tr.className = 'error-card';
        }
        
        headers.forEach(header => {
          const td = document.createElement('td');
          td.className = 'mdl-data-table__cell--non-numeric';
          
          // Text kürzen, wenn er zu lang ist
          let content = row[header] || '';
          
          // Behandlung für die Dateinamen-Spalte
          if (header === 'Dateinamen als String' && content.length > 100) {
            // Anzahl der Dateien ermitteln
            const fileCount = content.split(',').length;
            // Nur die ersten 3 Dateien anzeigen
            const firstFiles = content.split(',').slice(0, 3).join(', ');
            content = firstFiles + ` ... (${fileCount} Dateien insgesamt)`;
          } else if (content.length > 100) {
            content = content.substring(0, 100) + '...';
          }
          
          // Fehlermuster hervorheben
          if (header === 'Fehlermeldung' || header === 'Text') {
            const patternContainer = document.createElement('div');
            let textContent = content;
            
            // Bekannte Fehlermuster markieren
            knownErrorPatterns.forEach(pattern => {
              if (content.includes(pattern)) {
                const badge = document.createElement('span');
                badge.className = 'pattern-badge';
                badge.textContent = pattern;
                patternContainer.appendChild(badge);
                
                // Muster im Text ersetzen, damit es nicht doppelt angezeigt wird
                textContent = textContent.replace(pattern, '');
              }
            });
            
            // Nur den Text hinzufügen, wenn nach den Badges noch Text übrig ist
            if (textContent.trim()) {
              const textSpan = document.createElement('div');
              textSpan.className = 'pattern-container';
              textSpan.textContent = textContent;
              patternContainer.appendChild(textSpan);
            }
            
            td.appendChild(patternContainer);
          } else {
            td.textContent = content;
          }
          
          tr.appendChild(td);
        });
        
        tbody.appendChild(tr);
      });
      
      table.appendChild(tbody);
      container.appendChild(table);
      
      // MDL-Komponenten aktualisieren
      if (typeof componentHandler !== 'undefined') {
        componentHandler.upgradeElement(table);
      }
    }

    // Fehler-Typ-Kuchendiagramm erstellen
    function createErrorTypePieChart() {
      if (filteredPatternData.length === 0) return;
      
      // Fehler nach Muster gruppieren
      const errorsByType = {};
      
      filteredPatternData.forEach(entry => {
        const pattern = entry.Muster;
        
        if (!errorsByType[pattern]) {
          errorsByType[pattern] = 0;
        }
        
        errorsByType[pattern]++;
      });
      
      // Nach Häufigkeit sortieren
      const sortedErrors = Object.entries(errorsByType)
        .sort((a, b) => b[1] - a[1]);
      
      // Alle Fehlertypen anzeigen
      const labels = [];
      const data = [];
      
      // Dynamisch Farben für beliebig viele Einträge erstellen
      const generateColors = (count) => {
        const colors = [];
        const baseColors = [
          'rgba(255, 99, 132, 0.7)',
          'rgba(54, 162, 235, 0.7)',
          'rgba(255, 206, 86, 0.7)',
          'rgba(75, 192, 192, 0.7)',
          'rgba(153, 102, 255, 0.7)',
          'rgba(255, 159, 64, 0.7)',
          'rgba(201, 203, 207, 0.7)',
          'rgba(119, 221, 119, 0.7)',
          'rgba(179, 106, 200, 0.7)',
          'rgba(225, 123, 36, 0.7)'
        ];
        
        // Verwende die Basisfarben für die ersten Einträge
        for (let i = 0; i < count; i++) {
          if (i < baseColors.length) {
            colors.push(baseColors[i]);
          } else {
            // Für weitere Einträge generiere Farben basierend auf Position
            const hue = (i * 137.508) % 360; // Goldener Schnitt für gute Farbverteilung
            colors.push(`hsla(${hue}, 70%, 60%, 0.7)`);
          }
        }
        
        return colors;
      };
      
      sortedErrors.forEach((error) => {
        labels.push(error[0]);
        data.push(error[1]);
      });
      
      // Chart erstellen
      const ctx = document.getElementById('errorTypePieChart').getContext('2d');
      if (window.errorTypePieChart instanceof Chart) {
        window.errorTypePieChart.destroy();
      }
      
      window.errorTypePieChart = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            data: data,
            backgroundColor: generateColors(labels.length),
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: {
                boxWidth: 15,
                font: {
                  size: 11
                }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const label = context.label || '';
                  const value = context.raw || 0;
                  const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                  const percentage = ((value / total) * 100).toFixed(1);
                  return `${label}: ${value} (${percentage}%)`;
                }
              }
            }
          }
        }
      });
    }

    // Initial alle Daten laden
    loadConfig();
    
    // Datumsfilter initialisieren
    initDateFilter();
    
    // Alle 60 Sekunden aktualisieren
    setInterval(loadAllData, 60000);

    // Theme-Toggle-Button Funktionalität
    document.getElementById('themeToggle').addEventListener('change', function() {
      if (this.checked) {
        document.documentElement.setAttribute('data-theme', 'dark');
      } else {
        document.documentElement.setAttribute('data-theme', 'light');
      }
    });

    // Datum anpassen
    function adjustDate(inputId, amount, unit) {
      const input = document.getElementById(inputId);
      if (!input || !input.value) return;

      const currentDate = new Date(input.value);
      if (unit === 'day') {
        currentDate.setDate(currentDate.getDate() + amount);
      } else if (unit === 'month') {
        currentDate.setMonth(currentDate.getMonth() + amount);
      }

      input.value = currentDate.toISOString().split('T')[0];
      applyDateFilter();
    }

    // Zeit anpassen
    function adjustTime(inputId, amount, unit) {
      const input = document.getElementById(inputId);
      if (!input || !input.value) return;

      const [hours, minutes] = input.value.split(':').map(num => parseInt(num));
      const currentTime = new Date();
      currentTime.setHours(hours, minutes, 0);

      if (unit === 'hour') {
        currentTime.setHours(currentTime.getHours() + amount);
      } else if (unit === 'minute') {
        currentTime.setMinutes(currentTime.getMinutes() + amount);
      }

      const adjustedHours = currentTime.getHours().toString().padStart(2, '0');
      const adjustedMinutes = currentTime.getMinutes().toString().padStart(2, '0');
      input.value = `${adjustedHours}:${adjustedMinutes}`;
      applyDateFilter();
    }
  </script>
</body>
</html>