<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <title>AnyFileMonitor Dashboard</title>
  <!-- Material Design Lite -->
  <link rel="stylesheet" href="libs/fonts/material-icons.css">
  <link rel="stylesheet" href="libs/css/material.indigo-pink.min.css">
  <script defer src="libs/js/material.min.js"></script>
  <!-- PapaParse für CSV-Parsing -->
  <script src="libs/js/papaparse.min.js"></script>
  <!-- Chart.js für Diagramme -->
  <script src="libs/js/chart.js"></script>
  <script src="libs/js/chartjs-plugin-datalabels.js"></script>
  <!-- Moment.js für Datumsfunktionen -->
  <script src="libs/js/moment.min.js"></script>
  <script src="libs/js/moment-de.js"></script>
  <style>
    body { 
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f5f5f5;
    }
    .page-content {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .mdl-card {
      width: 100%;
      margin-bottom: 24px;
      overflow: visible;
    }
    .mdl-card__title {
      color: #fff;
      height: 64px;
      background-color: #3f51b5;
    }
    .mdl-card__title-text {
      font-size: 20px;
    }
    .mdl-data-table {
      width: 100%;
    }
    .summary-card {
      padding: 16px;
      margin-bottom: 24px;
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    .summary-item {
      text-align: center;
      padding: 16px;
      flex: 1;
      min-width: 150px;
    }
    .summary-value {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 8px;
      color: #3f51b5;
    }
    .summary-label {
      font-size: 14px;
      color: #757575;
    }
    .chart-container {
      height: 300px;
      margin-bottom: 24px;
    }
    .small-chart-container {
      height: 250px;
      margin-bottom: 16px;
    }
    .refresh-button {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 100;
    }
    .mdl-spinner {
      margin: 0 auto;
      display: block;
    }
    .loading {
      text-align: center;
      padding: 24px;
    }
    .error-card {
      background-color: #ffebee;
      border-left: 4px solid #f44336;
    }
    .warning-card {
      background-color: #fff8e1;
      border-left: 4px solid #ffc107;
    }
    .success-card {
      background-color: #e8f5e9;
      border-left: 4px solid #4caf50;
    }
    #lastUpdate {
      text-align: right;
      color: #757575;
      font-size: 12px;
      margin-bottom: 16px;
    }
    .mdl-layout__header-row {
      padding-left: 40px;
    }
    .mdl-grid {
      padding: 0;
    }
    .mdl-cell {
      margin: 8px;
    }
    .kpi-card {
      padding: 16px;
      text-align: center;
      border-radius: 8px;
      border-top: 4px solid #3f51b5;
      background-color: white;
      box-shadow: 0 2px 5px 0 rgba(0,0,0,0.16), 0 2px 10px 0 rgba(0,0,0,0.12);
    }
    .kpi-value {
      font-size: 28px;
      font-weight: bold;
      margin: 8px 0;
    }
    .kpi-label {
      font-size: 14px;
      color: #757575;
    }
    .status-indicator {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      margin-right: 8px;
    }
    .status-good {
      background-color: #4caf50;
    }
    .status-warning {
      background-color: #ff9800;
    }
    .status-error {
      background-color: #f44336;
    }
    .filter-container {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    .filter-item {
      margin: 8px;
    }
    .tab-container {
      display: none;
    }
    .tab-container.active {
      display: block;
    }
    .pattern-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      color: white;
      background-color: #3f51b5;
      margin-right: 4px;
      margin-bottom: 4px;
    }
    .pattern-container {
      margin-top: 8px;
    }
    #searchInput {
      padding: 8px;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .info-icon {
      font-size: 16px;
      color: #757575;
      cursor: help;
    }
    .tooltip {
      position: relative;
      display: inline-block;
    }
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    .two-columns {
      column-count: 2;
      column-gap: 20px;
    }
    .gauge-container {
      width: 200px;
      height: 100px;
      margin: 0 auto;
      position: relative;
    }
    .gauge-container canvas {
      width: 100%;
      height: 100%;
    }
    .gauge-label {
      position: absolute;
      bottom: 0;
      width: 100%;
      text-align: center;
      font-size: 14px;
      color: #757575;
    }
  </style>
</head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header">
    <header class="mdl-layout__header">
      <div class="mdl-layout__header-row">
        <span class="mdl-layout-title">AnyFileMonitor Dashboard</span>
        <div class="mdl-layout-spacer"></div>
        <nav class="mdl-navigation">
          <a class="mdl-navigation__link" href="#overview" onclick="showTab('overview')">Übersicht</a>
          <a class="mdl-navigation__link" href="#status" onclick="showTab('status')">Status</a>
          <a class="mdl-navigation__link" href="#analysis" onclick="showTab('analysis')">Analyse</a>
          <a class="mdl-navigation__link" href="#errors" onclick="showTab('errors')">Fehler</a>
          <a class="mdl-navigation__link" href="#patterns" onclick="showTab('patterns')">Muster</a>
          <a class="mdl-navigation__link" href="#input" onclick="showTab('input')">Eingangsdaten</a>
        </nav>
      </div>
    </header>
    <div class="mdl-layout__drawer">
      <span class="mdl-layout-title">AFM Dashboard</span>
      <nav class="mdl-navigation">
        <a class="mdl-navigation__link" href="#overview" onclick="showTab('overview')">Übersicht</a>
        <a class="mdl-navigation__link" href="#status" onclick="showTab('status')">Status</a>
        <a class="mdl-navigation__link" href="#analysis" onclick="showTab('analysis')">Analyse</a>
        <a class="mdl-navigation__link" href="#errors" onclick="showTab('errors')">Fehler</a>
        <a class="mdl-navigation__link" href="#patterns" onclick="showTab('patterns')">Muster</a>
        <a class="mdl-navigation__link" href="#input" onclick="showTab('input')">Eingangsdaten</a>
      </nav>
    </div>
    <main class="mdl-layout__content">
      <div class="page-content">
        <div id="lastUpdate"></div>

        <!-- Filter für Zeitraum -->
        <div class="filter-container mdl-shadow--2dp" style="padding: 16px; background-color: white;">
          <div class="filter-item">
            <div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label">
              <input class="mdl-textfield__input" type="date" id="startDate">
              <label class="mdl-textfield__label" for="startDate">Startdatum</label>
            </div>
          </div>
          <div class="filter-item">
            <div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label">
              <input class="mdl-textfield__input" type="date" id="endDate">
              <label class="mdl-textfield__label" for="endDate">Enddatum</label>
            </div>
          </div>
          <div class="filter-item">
            <button class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--colored" onclick="applyDateFilter()">
              Filter anwenden
            </button>
          </div>
          <div class="filter-item">
            <button class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect" onclick="resetDateFilter()">
              Filter zurücksetzen
            </button>
          </div>
        </div>

        <!-- Übersicht Tab -->
        <div id="overview" class="tab-container active">
          <!-- Zusammenfassung -->
          <div class="mdl-grid summary-card mdl-shadow--2dp">
            <div class="summary-item">
              <div class="summary-value" id="totalFiles">-</div>
              <div class="summary-label">Dateien gesamt</div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="errorCount">-</div>
              <div class="summary-label">Fehler</div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="patternCount">-</div>
              <div class="summary-label">Muster erkannt</div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="errorRate">-</div>
              <div class="summary-label">Fehlerrate</div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="lastRunTime">-</div>
              <div class="summary-label">Letzte Ausführung</div>
            </div>
            <div class="summary-item">
              <div class="summary-value" id="systemStatus">
                <span class="status-indicator status-good" id="statusIndicator"></span>
                <span id="statusText">Gut</span>
              </div>
              <div class="summary-label">Systemstatus</div>
            </div>
          </div>

          <!-- System-Gesundheit -->
          <div class="mdl-grid">
            <div class="mdl-cell mdl-cell--4-col">
              <div class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">System-Gesundheit</h2>
                </div>
                <div class="mdl-card__supporting-text">
                  <div class="gauge-container">
                    <canvas id="healthGauge"></canvas>
                    <div class="gauge-label">Systemstatus</div>
                  </div>
                  <div style="margin-top: 16px; text-align: center;">
                    <span id="healthScore">100%</span> Gesundheit
                  </div>
                </div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--4-col">
              <div class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">Fehler-Verteilung</h2>
                </div>
                <div class="mdl-card__supporting-text">
                  <div class="small-chart-container">
                    <canvas id="errorTypePieChart"></canvas>
                  </div>
                </div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--4-col">
              <div class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">Top Fehler</h2>
                </div>
                <div class="mdl-card__supporting-text">
                  <div id="topErrorsList">Lädt...</div>
                </div>
              </div>
            </div>
          </div>

          <!-- KPI-Übersicht -->
          <div class="mdl-grid">
            <div class="mdl-cell mdl-cell--3-col">
              <div class="kpi-card">
                <div class="kpi-label">
                  Durchsatz (Dateien/Stunde)
                  <span class="tooltip">
                    <i class="material-icons info-icon">info_outline</i>
                    <span class="tooltiptext">Durchschnittliche Anzahl der verarbeiteten Dateien pro Stunde</span>
                  </span>
                </div>
                <div class="kpi-value" id="throughput">-</div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--3-col">
              <div class="kpi-card">
                <div class="kpi-label">
                  Archiv : Fehler
                  <span class="tooltip">
                    <i class="material-icons info-icon">info_outline</i>
                    <span class="tooltiptext">Verhältnis zwischen archivierten und fehlerhaften Dateien</span>
                  </span>
                </div>
                <div class="kpi-value" id="archiveToErrorRatio">-</div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--3-col">
              <div class="kpi-card">
                <div class="kpi-label">
                  MTBF
                  <span class="tooltip">
                    <i class="material-icons info-icon">info_outline</i>
                    <span class="tooltiptext">Mean Time Between Failures (Durchschnittliche Zeit zwischen Fehlern)</span>
                  </span>
                </div>
                <div class="kpi-value" id="mtbf">-</div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--3-col">
              <div class="kpi-card">
                <div class="kpi-label">
                  Muster-Erkennungsrate
                  <span class="tooltip">
                    <i class="material-icons info-icon">info_outline</i>
                    <span class="tooltiptext">Prozentsatz der Fehler, die einem bekannten Muster zugeordnet werden können</span>
                  </span>
                </div>
                <div class="kpi-value" id="patternRecognitionRate">-</div>
              </div>
            </div>
          </div>

          <!-- Fehler nach Tageszeit -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehler nach Tageszeit</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="errorsByHourChart"></canvas>
              </div>
            </div>
          </div>
        </div>

        <!-- Status Tab -->
        <div id="status" class="tab-container">
          <!-- Status-Diagramm -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Status-Verlauf</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="statusChart"></canvas>
              </div>
            </div>
          </div>

          <!-- Status-Log -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Status-Log (AFM_status_log.csv)</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div id="statusTable" class="loading">
                <div class="mdl-spinner mdl-js-spinner is-active"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Analyse Tab -->
        <div id="analysis" class="tab-container">
          <!-- Fehler-Trend nach Typ -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehler-Trend nach Typ</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div class="chart-container">
                <canvas id="errorTrendChart"></canvas>
              </div>
            </div>
          </div>
          
          <!-- Verarbeitungseffizienz -->
          <div class="mdl-grid">
            <div class="mdl-cell mdl-cell--6-col">
              <div class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">Fehlerrate-Verlauf</h2>
                </div>
                <div class="mdl-card__supporting-text">
                  <div class="small-chart-container">
                    <canvas id="errorRateChart"></canvas>
                  </div>
                </div>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--6-col">
              <div class="mdl-card mdl-shadow--2dp">
                <div class="mdl-card__title">
                  <h2 class="mdl-card__title-text">Durchsatz-Verlauf</h2>
                </div>
                <div class="mdl-card__supporting-text">
                  <div class="small-chart-container">
                    <canvas id="throughputChart"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Fehler Tab -->
        <div id="errors" class="tab-container">
          <input type="text" id="searchInput" placeholder="Nach Dateinamen oder Fehlermeldung suchen..." onkeyup="searchErrors()">
          
          <!-- Fehler-Log -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Fehler-Log (AFM_error_log.csv)</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div id="errorTable" class="loading">
                <div class="mdl-spinner mdl-js-spinner is-active"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Muster Tab -->
        <div id="patterns" class="tab-container">
          <!-- Muster-Treffer -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Erkannte Muster (AFM_pattern_matches.csv)</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div id="patternTable" class="loading">
                <div class="mdl-spinner mdl-js-spinner is-active"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Eingangsdaten Tab -->
        <div id="input" class="tab-container">
          <!-- Eingangsdetails -->
          <div class="mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Eingangsdetails (AFM_input_details.csv)</h2>
            </div>
            <div class="mdl-card__supporting-text">
              <div id="inputTable" class="loading">
                <div class="mdl-spinner mdl-js-spinner is-active"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- Refresh Button -->
  <button class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect mdl-button--colored refresh-button" onclick="loadAllData()">
    <i class="material-icons">refresh</i>
  </button>

  <script>
    // Globale Variablen
    let allStatusData = [];
    let allErrorData = [];
    let allPatternData = [];
    let allInputData = [];
    let filteredStatusData = [];
    let filteredErrorData = [];
    let filteredPatternData = [];
    let filteredInputData = [];
    let startDateFilter = null;
    let endDateFilter = null;
    
    // Bekannte Fehlermuster aus config.ini
    const knownErrorPatterns = [
      "Timeout", 
      "Zeitüberschreitung", 
      "Verbindung vom peer", 
      "multiple Rows in singleton select", 
      "deadlock", 
      "lock conflict on no wait transaction"
    ];

    // Datumsfilter initialisieren
    function initDateFilter() {
      // Heutiges Datum
      const today = new Date();
      const todayFormatted = today.toISOString().split('T')[0]; // YYYY-MM-DD Format
      
      // Gestriges Datum
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayFormatted = yesterday.toISOString().split('T')[0]; // YYYY-MM-DD Format
      
      // Eingabefelder mit den Werten füllen
      document.getElementById('startDate').value = yesterdayFormatted;
      document.getElementById('endDate').value = todayFormatted;
      
      // Filter-Variablen setzen
      startDateFilter = yesterday;
      endDateFilter = new Date(today);
      endDateFilter.setHours(23, 59, 59, 999); // Ende des Tages
      
      // Filter anwenden
      applyFilters();
    }

    // Tab-Steuerung
    function showTab(tabId) {
      // Alle Tabs verstecken
      document.querySelectorAll('.tab-container').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Ausgewählten Tab anzeigen
      document.getElementById(tabId).classList.add('active');
      
      // Aktivität in der Navigation markieren
      document.querySelectorAll('.mdl-navigation__link').forEach(link => {
        if (link.getAttribute('href') === '#' + tabId) {
          link.classList.add('is-active');
        } else {
          link.classList.remove('is-active');
        }
      });
    }

    // Datum-Filter anwenden
    function applyDateFilter() {
      const startInput = document.getElementById('startDate');
      const endInput = document.getElementById('endDate');
      
      startDateFilter = startInput.value ? new Date(startInput.value) : null;
      endDateFilter = endInput.value ? new Date(endInput.value) : null;
      
      if (endDateFilter) {
        // End-Datum auf Ende des Tages setzen
        endDateFilter.setHours(23, 59, 59, 999);
      }
      
      applyFilters();
      processAllData();
    }

    // Datum-Filter zurücksetzen
    function resetDateFilter() {
      document.getElementById('startDate').value = '';
      document.getElementById('endDate').value = '';
      startDateFilter = null;
      endDateFilter = null;
      
      applyFilters();
      processAllData();
    }

    // Filter auf Daten anwenden
    function applyFilters() {
      filteredStatusData = filterDataByDate(allStatusData);
      filteredErrorData = filterDataByDate(allErrorData);
      filteredPatternData = filterDataByDate(allPatternData);
      filteredInputData = filterDataByDate(allInputData);
    }

    // Datum-Filter anwenden
    function filterDataByDate(data) {
      if (!startDateFilter && !endDateFilter) {
        return [...data]; // Kopie des Arrays zurückgeben, wenn kein Filter aktiv
      }
      
      return data.filter(row => {
        if (!row.Zeitpunkt) return true;
        
        const rowDate = new Date(row.Zeitpunkt);
        
        if (startDateFilter && rowDate < startDateFilter) return false;
        if (endDateFilter && rowDate > endDateFilter) return false;
        
        return true;
      });
    }

    // Fehlertabelle durchsuchen
    function searchErrors() {
      const searchTerm = document.getElementById('searchInput').value.toLowerCase();
      const errorTable = document.getElementById('errorTable');
      
      if (!errorTable) return;
      
      const rows = errorTable.querySelectorAll('tbody tr');
      
      rows.forEach(row => {
        const rowText = row.textContent.toLowerCase();
        if (rowText.includes(searchTerm)) {
          row.style.display = '';
        } else {
          row.style.display = 'none';
        }
      });
    }

    // Daten laden
    function loadAllData() {
      document.getElementById('lastUpdate').textContent = 'Letzte Aktualisierung: ' + new Date().toLocaleString('de-DE');
      loadCSV('./AFM_status_log.csv', function(results) {
        allStatusData = results.data || [];
        filteredStatusData = filterDataByDate(allStatusData);
        processStatusData({ data: filteredStatusData });
      });
      
      loadCSV('./AFM_error_log.csv', function(results) {
        allErrorData = results.data || [];
        filteredErrorData = filterDataByDate(allErrorData);
        processErrorData({ data: filteredErrorData });
      });
      
      loadCSV('./AFM_pattern_matches.csv', function(results) {
        allPatternData = results.data || [];
        filteredPatternData = filterDataByDate(allPatternData);
        processPatternData({ data: filteredPatternData });
      });
      
      loadCSV('./AFM_input_details.csv', function(results) {
        allInputData = results.data || [];
        filteredInputData = filterDataByDate(allInputData);
        processInputData({ data: filteredInputData });
      });
    }

    function processAllData() {
      processStatusData({ data: filteredStatusData });
      processErrorData({ data: filteredErrorData });
      processPatternData({ data: filteredPatternData });
      processInputData({ data: filteredInputData });
      
      // Zusätzliche Analysen
      calculateKPIs();
      createErrorTrendChart();
      createErrorRateChart();
      createThroughputChart();
      createErrorsByHourChart();
      createErrorTypePieChart();
      updateTopErrorsList();
      updateSystemHealthGauge();
    }

    function loadCSV(file, callback) {
      Papa.parse(file, {
        download: true,
        header: true,
        delimiter: ";", // Semikolon als Trennzeichen festlegen
        skipEmptyLines: true,
        complete: callback
      });
    }

    // Status-Daten verarbeiten
    function processStatusData(results) {
      if (!results.data || results.data.length === 0) {
        document.getElementById('statusTable').innerHTML = '<p>Keine Status-Daten verfügbar.</p>';
        return;
      }

      // Tabelle erstellen
      renderTable(results.data, 'statusTable');

      // Letzte Ausführung anzeigen
      const lastRun = results.data[results.data.length - 1];
      if (lastRun && lastRun.Zeitpunkt) {
        document.getElementById('lastRunTime').textContent = lastRun.Zeitpunkt.split(' ')[1] || '-';
      }

      // Daten für das Chart vorbereiten
      const labels = [];
      const inputData = [];
      const errorData = [];
      const archiveData = [];

      // Daten aus den Ergebnissen extrahieren
      results.data.forEach(entry => {
        if (entry.Zeitpunkt) {
          labels.push(entry.Zeitpunkt);
          inputData.push(parseInt(entry['Input'] || 0));
          errorData.push(parseInt(entry['Error'] || 0));
          archiveData.push(parseInt(entry['Archiv'] || 0));
        }
      });

      // Chart erstellen
      const ctx = document.getElementById('statusChart').getContext('2d');
      if (window.statusChart instanceof Chart) {
        window.statusChart.destroy();
      }
      
      window.statusChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Input',
              data: inputData,
              borderColor: 'rgba(54, 162, 235, 1)',
              backgroundColor: 'rgba(54, 162, 235, 0.2)',
              tension: 0.1
            },
            {
              label: 'Error',
              data: errorData,
              borderColor: 'rgba(255, 99, 132, 1)',
              backgroundColor: 'rgba(255, 99, 132, 0.2)',
              tension: 0.1
            },
            {
              label: 'Archiv',
              data: archiveData,
              borderColor: 'rgba(75, 192, 192, 1)',
              backgroundColor: 'rgba(75, 192, 192, 0.2)',
              tension: 0.1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });

      // Gesamtzahl der Dateien berechnen
      const lastEntry = results.data[results.data.length - 1];
      if (lastEntry) {
        const total = (parseInt(lastEntry['Input'] || 0) + 
                      parseInt(lastEntry['Error'] || 0) + 
                      parseInt(lastEntry['Archiv'] || 0));
        document.getElementById('totalFiles').textContent = total;
        
        // Fehlerrate berechnen - KORRIGIERT
        // Berechnung für korrekte Fehlerrate (Fehler / Gesamtdateien * 100)
        const errorCount = filteredErrorData.length;
        const errorRate = total > 0 ? ((errorCount / total) * 100).toFixed(1) + '%' : '0%';
        document.getElementById('errorRate').textContent = errorRate;
        
        // Systemstatus aktualisieren
        updateSystemStatus(errorRate);
      }
    }

    // Systemstatus aktualisieren
    function updateSystemStatus(errorRate) {
      const rateValue = parseFloat(errorRate);
      const indicator = document.getElementById('statusIndicator');
      const statusText = document.getElementById('statusText');
      
      if (rateValue < 5) {
        indicator.className = 'status-indicator status-good';
        statusText.textContent = 'Gut';
      } else if (rateValue < 10) {
        indicator.className = 'status-indicator status-warning';
        statusText.textContent = 'Warnung';
      } else {
        indicator.className = 'status-indicator status-error';
        statusText.textContent = 'Kritisch';
      }
    }

    // Fehler-Daten verarbeiten
    function processErrorData(results) {
      if (!results.data || results.data.length === 0) {
        document.getElementById('errorTable').innerHTML = '<p>Keine Fehler-Daten verfügbar.</p>';
        return;
      }

      document.getElementById('errorCount').textContent = results.data.length;
      renderTable(results.data, 'errorTable', true);
    }

    // Muster-Daten verarbeiten
    function processPatternData(results) {
      if (!results.data || results.data.length === 0) {
        document.getElementById('patternTable').innerHTML = '<p>Keine Muster-Daten verfügbar.</p>';
        return;
      }

      document.getElementById('patternCount').textContent = results.data.length;
      renderTable(results.data, 'patternTable', true);
    }

    // Eingangs-Daten verarbeiten
    function processInputData(results) {
      if (!results.data || results.data.length === 0) {
        document.getElementById('inputTable').innerHTML = '<p>Keine Eingangs-Daten verfügbar.</p>';
        return;
      }

      renderTable(results.data, 'inputTable');
    }

    // KPIs berechnen
    function calculateKPIs() {
      if (filteredStatusData.length === 0) return;
      
      // Durchsatz berechnen (Dateien pro Stunde)
      const lastEntry = filteredStatusData[filteredStatusData.length - 1];
      const totalFiles = parseInt(lastEntry['Input'] || 0) + 
                         parseInt(lastEntry['Archiv'] || 0) + 
                         parseInt(lastEntry['Error'] || 0);
      
      // Annahme: Daten werden stündlich erfasst
      const throughputPerHour = Math.round(totalFiles / filteredStatusData.length);
      document.getElementById('throughput').textContent = throughputPerHour;
      
      // Fehler-zu-Archiv-Verhältnis (umgekehrt im Vergleich zur vorherigen Berechnung)
      const archiveCount = parseInt(lastEntry['Archiv'] || 0);
      const errorCount = parseInt(lastEntry['Error'] || 0);
      let ratio = archiveCount > 0 ? ((errorCount / archiveCount) * 100).toFixed(1) + '%' : '∞';
      document.getElementById('archiveToErrorRatio').textContent = ratio;
      
      // MTBF (Mean Time Between Failures)
      // Annahme: Jeder Eintrag in filteredStatusData stellt einen Zeitpunkt dar
      // und die Anzahl der Fehler hat sich seit dem letzten Eintrag um die Differenz geändert
      let totalHours = filteredStatusData.length;
      let totalErrors = 0;
      
      if (filteredStatusData.length > 1) {
        const firstEntry = filteredStatusData[0];
        const firstErrorCount = parseInt(firstEntry['Error'] || 0);
        totalErrors = errorCount - firstErrorCount;
      } else {
        totalErrors = errorCount;
      }
      
      const mtbf = totalErrors > 0 ? (totalHours / totalErrors).toFixed(1) + 'h' : '∞';
      document.getElementById('mtbf').textContent = mtbf;
      
      // Muster-Erkennungsrate - Korrigiert
      // Direkter Vergleich zwischen erkannten Mustern und Fehlern
      const actualErrorCount = filteredErrorData.length;
      const patternMatchCount = filteredPatternData.length;
      
      // Wenn Muster und Fehler identisch sind (beide > 0), dann 100%
      // Sonst das tatsächliche Verhältnis
      let patternRecognitionRate;
      if (actualErrorCount > 0) {
        patternRecognitionRate = Math.min(100, Math.round((patternMatchCount / actualErrorCount) * 100)) + '%';
      } else {
        patternRecognitionRate = '0%';
      }
      
      document.getElementById('patternRecognitionRate').textContent = patternRecognitionRate;
    }

    // Fehler-Trend nach Typ erstellen
    function createErrorTrendChart() {
      if (filteredPatternData.length === 0) return;
      
      // Daten nach Datum und Muster gruppieren
      const errorTypesByDate = {};
      const errorTypes = new Set();
      
      filteredPatternData.forEach(entry => {
        const date = entry.Zeitpunkt.split(' ')[0];
        const pattern = entry.Muster;
        
        if (!errorTypesByDate[date]) {
          errorTypesByDate[date] = {};
        }
        
        if (!errorTypesByDate[date][pattern]) {
          errorTypesByDate[date][pattern] = 0;
        }
        
        errorTypesByDate[date][pattern]++;
        errorTypes.add(pattern);
      });
      
      // Daten für Chart.js vorbereiten
      const labels = Object.keys(errorTypesByDate).sort();
      const datasets = [];
      
      // Farben für verschiedene Fehlertypen
      const colors = [
        'rgba(255, 99, 132, 1)',
        'rgba(54, 162, 235, 1)',
        'rgba(255, 206, 86, 1)',
        'rgba(75, 192, 192, 1)',
        'rgba(153, 102, 255, 1)',
        'rgba(255, 159, 64, 1)'
      ];
      
      // Ein Dataset pro Fehlertyp erstellen
      Array.from(errorTypes).forEach((type, index) => {
        const data = labels.map(date => errorTypesByDate[date][type] || 0);
        
        datasets.push({
          label: type,
          data: data,
          borderColor: colors[index % colors.length],
          backgroundColor: colors[index % colors.length].replace('1)', '0.2)'),
          tension: 0.1
        });
      });
      
      // Chart erstellen
      const ctx = document.getElementById('errorTrendChart').getContext('2d');
      if (window.errorTrendChart instanceof Chart) {
        window.errorTrendChart.destroy();
      }
      
      window.errorTrendChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Fehler'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Datum'
              }
            }
          }
        }
      });
    }

    // Fehlerrate-Diagramm erstellen
    function createErrorRateChart() {
      if (filteredStatusData.length === 0) return;
      
      const labels = [];
      const errorRates = [];
      
      filteredStatusData.forEach(entry => {
        const total = parseInt(entry['Input'] || 0) + 
                       parseInt(entry['Archiv'] || 0) + 
                       parseInt(entry['Error'] || 0);
        const errorCount = parseInt(entry['Error'] || 0);
        const errorRate = total > 0 ? (errorCount / total) * 100 : 0;
        
        labels.push(entry.Zeitpunkt.split(' ')[1]);
        errorRates.push(errorRate);
      });
      
      // Chart erstellen
      const ctx = document.getElementById('errorRateChart').getContext('2d');
      if (window.errorRateChart instanceof Chart) {
        window.errorRateChart.destroy();
      }
      
      window.errorRateChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Fehlerrate (%)',
            data: errorRates,
            borderColor: 'rgba(255, 99, 132, 1)',
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Fehlerrate (%)'
              }
            }
          }
        }
      });
    }

    // Durchsatz-Diagramm erstellen
    function createThroughputChart() {
      if (filteredStatusData.length === 0) return;
      
      const labels = [];
      const throughputData = [];
      
      filteredStatusData.forEach(entry => {
        const total = parseInt(entry['Input'] || 0) + 
                       parseInt(entry['Archiv'] || 0) + 
                       parseInt(entry['Error'] || 0);
        
        labels.push(entry.Zeitpunkt.split(' ')[1]);
        throughputData.push(total);
      });
      
      // Chart erstellen
      const ctx = document.getElementById('throughputChart').getContext('2d');
      if (window.throughputChart instanceof Chart) {
        window.throughputChart.destroy();
      }
      
      window.throughputChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Dateien pro Intervall',
            data: throughputData,
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Dateien'
              }
            }
          }
        }
      });
    }

    // Fehler nach Stunde erstellen
    function createErrorsByHourChart() {
      if (filteredErrorData.length === 0) return;
      
      // Fehler nach Stunde gruppieren
      const errorsByHour = Array(24).fill(0);
      
      filteredErrorData.forEach(entry => {
        if (entry.Zeitpunkt) {
          const hour = parseInt(entry.Zeitpunkt.split(' ')[1].split(':')[0]);
          if (!isNaN(hour) && hour >= 0 && hour < 24) {
            errorsByHour[hour]++;
          }
        }
      });
      
      // Labels erstellen (0-23 Uhr)
      const labels = Array.from({length: 24}, (_, i) => `${i}:00`);
      
      // Chart erstellen
      const ctx = document.getElementById('errorsByHourChart').getContext('2d');
      if (window.errorsByHourChart instanceof Chart) {
        window.errorsByHourChart.destroy();
      }
      
      window.errorsByHourChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Fehler pro Stunde',
            data: errorsByHour,
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Anzahl der Fehler'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Stunde des Tages'
              }
            }
          }
        }
      });
    }

    // Fehlertypen-Verteilung (Pie-Chart)
    function createErrorTypePieChart() {
      if (filteredPatternData.length === 0) return;
      
      // Fehler nach Muster gruppieren
      const errorsByType = {};
      
      filteredPatternData.forEach(entry => {
        const pattern = entry.Muster;
        
        if (!errorsByType[pattern]) {
          errorsByType[pattern] = 0;
        }
        
        errorsByType[pattern]++;
      });
      
      // Daten für Chart.js vorbereiten
      const labels = Object.keys(errorsByType);
      const data = Object.values(errorsByType);
      
      // Farben für verschiedene Fehlertypen
      const backgroundColors = [
        'rgba(255, 99, 132, 0.2)',
        'rgba(54, 162, 235, 0.2)',
        'rgba(255, 206, 86, 0.2)',
        'rgba(75, 192, 192, 0.2)',
        'rgba(153, 102, 255, 0.2)',
        'rgba(255, 159, 64, 0.2)'
      ];
      
      const borderColors = [
        'rgba(255, 99, 132, 1)',
        'rgba(54, 162, 235, 1)',
        'rgba(255, 206, 86, 1)',
        'rgba(75, 192, 192, 1)',
        'rgba(153, 102, 255, 1)',
        'rgba(255, 159, 64, 1)'
      ];
      
      // Chart erstellen
      const ctx = document.getElementById('errorTypePieChart').getContext('2d');
      if (window.errorTypePieChart instanceof Chart) {
        window.errorTypePieChart.destroy();
      }
      
      window.errorTypePieChart = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            data: data,
            backgroundColor: backgroundColors.slice(0, labels.length),
            borderColor: borderColors.slice(0, labels.length),
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: {
                boxWidth: 12
              }
            }
          }
        }
      });
    }

    // Top Fehler-Liste aktualisieren
    function updateTopErrorsList() {
      const container = document.getElementById('topErrorsList');
      if (!container || filteredPatternData.length === 0) {
        if (container) container.innerHTML = 'Keine Daten verfügbar';
        return;
      }
      
      // Fehler nach Muster gruppieren und zählen
      const errorsByType = {};
      
      filteredPatternData.forEach(entry => {
        const pattern = entry.Muster;
        
        if (!errorsByType[pattern]) {
          errorsByType[pattern] = 0;
        }
        
        errorsByType[pattern]++;
      });
      
      // Nach Anzahl sortieren und die Top 5 nehmen
      const sortedErrors = Object.entries(errorsByType)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
      
      // HTML für die Liste erstellen
      const html = sortedErrors.map((error, index) => {
        return `
          <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
            <div>${index + 1}. ${error[0]}</div>
            <div><strong>${error[1]}</strong></div>
          </div>
        `;
      }).join('');
      
      container.innerHTML = html || 'Keine Fehler gefunden';
    }

    // System-Gesundheit Gauge aktualisieren
    function updateSystemHealthGauge() {
      if (filteredStatusData.length === 0) return;
      
      const lastEntry = filteredStatusData[filteredStatusData.length - 1];
      const totalFiles = parseInt(lastEntry['Input'] || 0) + 
                         parseInt(lastEntry['Archiv'] || 0) + 
                         parseInt(lastEntry['Error'] || 0);
      const errorCount = parseInt(lastEntry['Error'] || 0);
      
      // Gesundheit berechnen: 100% - Fehlerrate
      let healthPercentage = 100;
      if (totalFiles > 0) {
        const errorRate = (errorCount / totalFiles) * 100;
        healthPercentage = Math.max(0, 100 - errorRate);
      }
      
      // Gesundheitspunktzahl anzeigen
      document.getElementById('healthScore').textContent = healthPercentage.toFixed(1) + '%';
      
      // Gauge-Diagramm erstellen
      const ctx = document.getElementById('healthGauge').getContext('2d');
      if (window.healthGauge instanceof Chart) {
        window.healthGauge.destroy();
      }
      
      // Farbe basierend auf Gesundheit
      let color = 'rgba(75, 192, 192, 1)'; // Grün
      if (healthPercentage < 90) {
        color = 'rgba(255, 206, 86, 1)'; // Gelb
      }
      if (healthPercentage < 80) {
        color = 'rgba(255, 99, 132, 1)'; // Rot
      }
      
      window.healthGauge = new Chart(ctx, {
        type: 'doughnut',
        data: {
          datasets: [{
            data: [healthPercentage, 100 - healthPercentage],
            backgroundColor: [
              color,
              'rgba(200, 200, 200, 0.2)'
            ],
            circumference: 180,
            rotation: 270
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutout: '70%',
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              enabled: false
            }
          }
        }
      });
    }

    // Tabelle rendern
    function renderTable(data, containerId, highlightErrors = false) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';

      if (!data || data.length === 0) {
        container.innerHTML = '<p>Keine Daten verfügbar.</p>';
        return;
      }

      // Tabelle erstellen
      const table = document.createElement('table');
      table.className = 'mdl-data-table mdl-js-data-table mdl-shadow--2dp';
      
      // Header erstellen
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      
      // Spaltenüberschriften aus dem ersten Datensatz
      const headers = Object.keys(data[0]);
      headers.forEach(header => {
        const th = document.createElement('th');
        th.className = 'mdl-data-table__cell--non-numeric';
        th.textContent = header;
        headerRow.appendChild(th);
      });
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Tabellenkörper erstellen
      const tbody = document.createElement('tbody');
      
      // Nur die letzten 100 Einträge anzeigen, um die Leistung zu verbessern
      const displayData = data.length > 100 ? data.slice(-100) : data;
      
      displayData.forEach(row => {
        const tr = document.createElement('tr');
        
        // Zeile hervorheben, wenn sie einen Fehler enthält
        if (highlightErrors && row.Muster) {
          tr.className = 'error-card';
        }
        
        headers.forEach(header => {
          const td = document.createElement('td');
          td.className = 'mdl-data-table__cell--non-numeric';
          
          // Text kürzen, wenn er zu lang ist
          let content = row[header] || '';
          
          // Behandlung für die Dateinamen-Spalte
          if (header === 'Dateinamen als String' && content.length > 100) {
            // Anzahl der Dateien ermitteln
            const fileCount = content.split(',').length;
            // Nur die ersten 3 Dateien anzeigen
            const firstFiles = content.split(',').slice(0, 3).join(', ');
            content = firstFiles + ` ... (${fileCount} Dateien insgesamt)`;
          } else if (content.length > 100) {
            content = content.substring(0, 100) + '...';
          }
          
          // Fehlermuster hervorheben
          if (header === 'Fehlermeldung' || header === 'Text') {
            const patternContainer = document.createElement('div');
            let textContent = content;
            
            // Bekannte Fehlermuster markieren
            knownErrorPatterns.forEach(pattern => {
              if (content.includes(pattern)) {
                const badge = document.createElement('span');
                badge.className = 'pattern-badge';
                badge.textContent = pattern;
                patternContainer.appendChild(badge);
                
                // Muster im Text ersetzen, damit es nicht doppelt angezeigt wird
                textContent = textContent.replace(pattern, '');
              }
            });
            
            // Nur den Text hinzufügen, wenn nach den Badges noch Text übrig ist
            if (textContent.trim()) {
              const textSpan = document.createElement('div');
              textSpan.className = 'pattern-container';
              textSpan.textContent = textContent;
              patternContainer.appendChild(textSpan);
            }
            
            td.appendChild(patternContainer);
          } else {
            td.textContent = content;
          }
          
          tr.appendChild(td);
        });
        
        tbody.appendChild(tr);
      });
      
      table.appendChild(tbody);
      container.appendChild(table);
      
      // MDL-Komponenten aktualisieren
      if (typeof componentHandler !== 'undefined') {
        componentHandler.upgradeElement(table);
      }
    }

    // Initial alle Daten laden
    loadAllData();
    
    // Datumsfilter initialisieren
    initDateFilter();
    
    // Alle 60 Sekunden aktualisieren
    setInterval(loadAllData, 60000);
  </script>
</body>
</html>